"""
Create restructured text pages for module's default parameters.

These pages are then appended to the module's documentation page. See the
`.. include::` statement in the module's `.rst` file in the `docs/` folder.
The created files are save to `docs/modules/*/params/*.rst` files.

The pages generated by this script are not stagged to github. They are used
temporary just to create the HTML files for the documentation.
"""
import os
from collections.abc import Mapping
from pathlib import Path

from haddock import haddock3_repository_path, haddock3_source_path
from haddock.libs.libio import read_from_yaml


class HeadingController:
    """
    Control headings.

    reStructured text headings are defined by punctuation characters.

    In HADDOCK3 docs we use the order: '=', '-', '`', '~', '*'.

    The first heading tags is taken by the main docs. Therefore,
    `HeadingController` manages only from the second ('-') onward.

    Read more at: https://thomas-cokelaer.info/tutorials/sphinx/rest_syntax.html#headings
    """  # noqa: E501

    def __init__(self):
        self.title_headings = ['-', '`', '~', '*']
        self._idx = 0

    @property
    def next(self):
        """Give the next heading char."""
        return self.title_headings[self._idx + 1]

    @property
    def current(self):
        """Give the current heading char."""
        return self.title_headings[self._idx]

    def reset(self):
        """Reset to the first heading."""
        self._idx = 0

    def increase(self):
        """Increase current heading."""
        self._idx += 1


HEADING = HeadingController()


# prepare YAML markdown files
def main():
    """
    Prepare restructured text files from YAML default configs in modules.

    These files are written to the 'docs/' folder but not stagged to
    github. Instead, they are used only by Sphinx to generate the HTML
    documentation pages.
    """
    # uses this pattern instead of importing:
    # from haddock.modules import modules_category
    # to avoid importing dependencies of the haddock modules packages
    pattern = Path('modules', '*', '*', '*.yaml')
    configs = list(haddock3_source_path.glob(str(pattern)))

    # create RST pages for all modules' configuration files.
    for config in configs:

        module_name = config.parents[0].name
        category = config.parents[1].name
        params = read_from_yaml(config)

        # ignore empty modules - currently topocg for example
        if len(params) == 0:
            continue

        HEADING.reset()
        HEADING.increase()
        text = build_rst(params)

        params_folder = Path(
            haddock3_repository_path,
            'docs',
            'modules',
            category,
            'params',
            )
        params_folder.mkdir(exist_ok=True)

        with open(Path(params_folder, f'{module_name}.rst'), 'w') as fout:
            fout.write(text)

    # Generate general default parameters RST page
    HEADING.reset()
    HEADING.increase()
    general_defaults = Path(haddock3_source_path, 'modules', 'defaults.yaml')
    general_params = read_from_yaml(general_defaults)
    text = build_rst(general_params)
    params_file = Path(
        haddock3_repository_path,
        'docs',
        'modules',
        'general_module_params.rst',
        )

    with open(params_file, 'w') as fout:
        fout.write(text)

    # Generate mandatory parameters RST page
    HEADING.reset()
    mandatory_defaults = Path(haddock3_source_path, 'core', 'mandatory.yaml')
    mandatory_params = read_from_yaml(mandatory_defaults)

    for param in mandatory_params:
        mandatory_params[param]["default"] = \
            "No default assigned, this parameter is mandatory"

    text = build_rst(mandatory_params)
    params_file = Path(
        haddock3_repository_path,
        'docs',
        'reference',
        'core',
        'mandatory_parameters.rst',
        )

    with open(params_file, 'w') as fout:
        fout.write('Mandatory Parameters' + os.linesep)
        fout.write('====================' + os.linesep)
        fout.write(text)


def do_text(name, param, level):
    """Create text from parameter dictionary."""
    text = [
        f'{name}',
        f'{level * len(name)}',
        '',
        f'| *default*: {param["default"]!r}',
        f'| *type*: {param["type"]}',
        f'| *title*: {param["title"]}',
        f'| *short description*: {param["short"]}',
        f'| *long description*: {param["long"]}',
        f'| *group*: {param.get("group", "No group assigned")}',
        f'| *explevel*: {param["explevel"]}',
        '',
        ]

    return os.linesep.join(text)


def loop_params(config, easy, expert, guru):
    """
    Treat parameters for module.

    *Important:* considers that some configuration files can have
    dictionaries with subparameters. However, there should NOT be more
    than one level of nesting in the configuration parameter files.
    """
    # sort parameters by name
    sorted_ = sorted(
        ((k, v) for k, v in config.items()),
        key=lambda x: x[0],
        )

    for name, data in sorted_:

        # case for nested parameters like `mol1` in topoaa
        if isinstance(data, Mapping) and "default" not in data:

            explevel = data["explevel"]
            new_title = [name, HEADING.current * len(name), '']

            if explevel == 'easy':
                easy.extend(new_title)
                sublist = easy
            elif explevel == 'expert':
                expert.extend(new_title)
                sublist = expert
            elif explevel == 'guru':
                guru.extend(new_title)
                sublist = guru
            elif explevel == 'hidden':
                continue
            else:
                emsg = f'explevel {explevel!r} is not expected'
                raise AssertionError(emsg)

            data_text = (
                f'| *title*: {data["title"]}',
                f'| *short description*: {data["short"]}',
                f'| *long description*: {data["long"]}',
                f'| *group*: {data["group"]}',
                f'| *explevel*: {explevel}',
                '',
                )
            sublist.append(os.linesep.join(data_text))

            # create subparameters RST sorted by name
            data_sorted = sorted(
                ((k, v) for k, v in data.items()),
                key=lambda x: x[0],
                )
            for name2, param2 in data_sorted:
                if isinstance(param2, Mapping):
                    text = do_text(
                        f'{name}.{name2}',
                        param2,
                        level=HEADING.next,
                        )
                    sublist.append(text)

        # case for normal parameter
        elif isinstance(data, Mapping):

            explevel = data["explevel"]
            text = do_text(name, data, level=HEADING.current)

            if explevel == 'easy':
                easy.append(text)
            elif explevel == 'expert':
                expert.append(text)
            elif explevel == 'guru':
                guru.append(text)
            elif explevel == 'hidden':
                continue
            else:
                emsg = f'explevel {explevel!r} is not expected'
                raise AssertionError(emsg)
        else:
            emsg = f'Unexpected parameter behaviour: {name!r}'
            raise AssertionError(emsg)

    easy.append('')
    expert.append('')
    guru.append('')

    return easy, expert, guru


def build_rst(module_params):
    """Build .rst text."""
    easy = ['Easy', HEADING.current * 4, '']
    expert = ["Expert", HEADING.current * 6, '']
    guru = ['Guru', HEADING.current * 4, '']

    HEADING.increase()
    easy, expert, guru = loop_params(module_params, easy, expert, guru)

    doc = []
    for list_ in (easy, expert, guru):
        if len(list_) > 4:
            doc.extend(list_)

    text = os.linesep + os.linesep + os.linesep.join(doc)
    return text


if __name__ == "__main__":
    main()
