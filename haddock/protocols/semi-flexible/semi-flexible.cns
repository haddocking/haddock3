! refine.inp
!    The core docking script of HADDOCK performing rigid-body docking
!    and semi-flexible refinement in torsion angle space
!
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!

!@RUN:protocols/initialize.cns(iteration=$iteration;)
!
!@NEWIT:iteration.cns(iteration=$iteration;)
!
!@RUN:run.cns(
!iteration =$iteration;
!filenames =$filenames;
!Data      =$Data;
!iterations=$iterations;
!saprotocol=$saprotocol;
!refine    =$refine;
!toppar    =$toppar;
!analysis  =$analysis;)

!evaluate ($log_level=quiet)
!evaluate ($log_level=verbose)
!eval ($toppar.prot_segid_1="A")
!eval ($toppar.prot_segid_2="B")
!eval ($toppar.fix_origin_1=false)
!eval ($toppar.fix_origin_2=false)
!eval ($toppar.shape_1=false)
!eval ($toppar.shape_2=false)
!eval ($toppar.dna_1=false)
!eval ($toppar.dna_2=false)
eval ($iteration = 1)

noe
  reset
  nrestraints = 12000000     ! allocate space for NOEs
  ceiling 1000
end

!==================================================================!
evaluate ($saprotocol.crossdock=$crossdock)
evaluate ($saprotocol.randorien=$randorien)
evaluate ($saprotocol.rebuildcplx=$rebuildcplx)
evaluate ($saprotocol.rigidmini=$rigidmini)
evaluate ($saprotocol.rigidtrans=$rigidtrans)
evaluate ($saprotocol.expand=$expand)
evaluate ($saprotocol.expansion=$expansion)
evaluate ($saprotocol.randangle=$randangle)

if ($saprotocol.expand eq true) then
  evaluate ($saprotocol.randorien = false)
  evaluate ($saprotocol.rigidmini = false)
end if

evaluate ($saprotocol.ntrials=$ntrials)
evaluate ($saprotocol.iniseed=$iniseed)
evaluate ($saprotocol.tadhigh_t=$tadhigh_t)
evaluate ($saprotocol.t1_init=$tadinit1_t)
evaluate ($saprotocol.t2_init=$tadinit2_t)
evaluate ($saprotocol.t3_init=$tadinit3_t)
evaluate ($saprotocol.t1_final=$tadfinal1_t)
evaluate ($saprotocol.t2_final=$tadfinal2_t)
evaluate ($saprotocol.t3_final=$tadfinal3_t)
evaluate ($saprotocol.inter_rigid=$inter_rigid)
evaluate ($saprotocol.inter_init_rigid=$init_rigid)
evaluate ($saprotocol.inter_fin_rigid=$fin_rigid)
evaluate ($saprotocol.inter_init_cool2=$init_cool2)
evaluate ($saprotocol.inter_fin_cool2=$fin_cool2)
evaluate ($saprotocol.inter_init_cool3=$init_cool3)
evaluate ($saprotocol.inter_fin_cool3=$fin_cool3)
!evaluate ($saprotocol.rotate180_it0=$rotate180_it0)
evaluate ($saprotocol.rotate180_it1=$rotate180_it1)
evaluate ($saprotocol.tempstep=50)
evaluate ($saprotocol.timestep=$timestep)
evaluate ($saprotocol.tadfactor=$tadfactor)
evaluate ($saprotocol.emstepstrans=$emstepstrans)
evaluate ($saprotocol.initiosteps=$initiosteps)
evaluate ($saprotocol.cool1_steps=$cool1_steps)
evaluate ($saprotocol.cool2_steps=$cool2_steps)
evaluate ($saprotocol.cool3_steps=$cool3_steps)
evaluate ($saprotocol.fbeta=100)
evaluate ($saprotocol.mass=100)

evaluate ($fileroot="")
evaluate ($filenames.fileroot=$fileroot)
evaluate ($filenames.template=$fileroot + "_1.pdb")

evaluate ($iterations.ini_count    =1)
!evaluate ($iterations.structures   =$structures_$iteration)
!evaluate ($iterations.keepstruct   =$keepstruct_$iteration)
evaluate ($iterations.w_vdw        =$w_vdw_$iteration)
evaluate ($iterations.w_elec       =$w_elec_$iteration)
evaluate ($iterations.w_dist       =$w_dist_$iteration)
evaluate ($iterations.w_rg         =$w_rg_$iteration)
evaluate ($iterations.w_sani       =$w_sani_$iteration)
evaluate ($iterations.w_xrdc       =$w_xrdc_$iteration)
evaluate ($iterations.w_xpcs       =$w_xpcs_$iteration)
evaluate ($iterations.w_dani       =$w_dani_$iteration)
evaluate ($iterations.w_vean       =$w_vean_$iteration)
evaluate ($iterations.w_cdih       =$w_cdih_$iteration)
evaluate ($iterations.w_sym        =$w_sym_$iteration)
evaluate ($iterations.w_zres       =$w_zres_$iteration)
evaluate ($iterations.w_bsa        =$w_bsa_$iteration)
evaluate ($iterations.w_deint      =$w_deint_$iteration)
evaluate ($iterations.w_desolv     =$w_desolv_$iteration)
evaluate ($iterations.anastruc     =$anastruc_$iteration)
evaluate ($iterations.w_lcc        =$w_lcc_$iteration)


evaluate ($data.ncomponents=$ncomponents)
!
evaluate ($nmol=1)
while ($nmol <= $data.ncomponents) loop mol
!
!  !aa topology, linkage and parameters files
!  evaluate ($toppar.prot_top_$nmol=$prot_top_mol$nmol )
!  evaluate ($toppar.prot_link_$nmol=$prot_link_mol$nmol )
!  evaluate ($toppar.prot_par_$nmol=$prot_par_mol$nmol )
!
!  !coarse grained topology, linkage and parameters files
!  evaluate ($toppar.prot_cg_top_$nmol=$prot_cg_top_mol$nmol )
!  evaluate ($toppar.prot_cg_link_$nmol=$prot_cg_link_mol$nmol )
!  evaluate ($toppar.prot_cg_par_$nmol=$prot_cg_par_mol$nmol )
!
!  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid)
!  evaluate ($toppar.prot_coor_$nmol=$prot_coor_mol$nmol)
!  evaluate ($toppar.prot_root_$nmol=$prot_root_mol$nmol)
  evaluate ($toppar.fix_origin_$nmol=$fix_origin_mol$nmol)
!  evaluate ($toppar.dna_$nmol=$dna_mol$nmol)
!  evaluate ($toppar.cyclicpept_$nmol = $cyclicpept_mol$nmol)
!  evaluate ($toppar.shape_$nmol = $shape_mol$nmol)
!  evaluate ($toppar.cg_$nmol = $cg_mol$nmol)
  evaluate ($toppar.prot_segid_$nmol = $prot_segid_mol$nmol)

  !semi flexible segments
  evaluate ($toppar.nseg_$nmol = $nseg_$nmol)
  evaluate ($nseg = 1)
  while ($nseg <=$toppar.nseg_$nmol) loop seg
    evaluate ($toppar.start_seg_$nmol_$nseg = $start_seg_$nmol_$nseg)
    evaluate ($toppar.end_seg_$nmol_$nseg = $end_seg_$nmol_$nseg)
    evaluate ($nseg = $nseg + 1)
  end loop seg

  !fully flexible segments
  evaluate ($toppar.nfle_$nmol = $nfle_$nmol)
  evaluate ($nfle = 1)
  while ($nfle <=$toppar.nfle_$nmol) loop fle
    evaluate ($toppar.start_fle_$nmol_$nfle = $start_fle_$nmol_$nfle)
    evaluate ($toppar.end_fle_$nmol_$nfle = $end_fle_$nmol_$nfle)
    evaluate ($nfle = $nfle + 1)
  end loop fle
!
!  !histidine patches
  evaluate ($toppar.autohis = $autohis)
!  evaluate ($toppar.nhisd_$nmol = $numhisd_$nmol)
!  evaluate ($ncc=1)
!  while ($ncc <=$toppar.nhisd_$nmol) loop hisd
!    evaluate ($toppar.hisd_resid_$nmol_$ncc = $hisd_$nmol_$ncc)
!    evaluate ($ncc = $ncc + 1)
!  end loop hisd
!
!  evaluate ($toppar.nhise_$nmol = $numhise_$nmol)
!  evaluate ($ncc=1)
!  while ($ncc <=$toppar.nhise_$nmol) loop hisd
!    evaluate ($toppar.hise_resid_$nmol_$ncc = $hise_$nmol_$ncc)
!    evaluate ($ncc = $ncc + 1)
!  end loop hisd
!
  evaluate ($nmol = $nmol + 1)
end loop mol

! non-bonded parameter set to use
evaluate ($toppar.par_nonbonded = $par_nonbonded)

! z-restraining
evaluate ($Data.flags.zres = $zres_on)
evaluate ($data.numzres = $numzres)
evaluate ($ncc=1)
while ($ncc <= $numzres) loop zres
  evaluate ($toppar.zres_sta_$ncc = $zres_sta_$ncc)
  evaluate ($toppar.zres_end_$ncc = $zres_end_$ncc)
  evaluate ($toppar.zres_seg_$ncc = $zres_seg_$ncc)
  evaluate ($toppar.zres_type_$ncc = $zres_type_$ncc)
  evaluate ($ncc = $ncc + 1)
end loop zres

! NCS restraints
evaluate ($data.kncs = $kncs)
evaluate ($Data.flags.ncs = $ncs_on)
evaluate ($data.numncs = $numncs)
evaluate ($ncc=1)
while ($ncc <= $numncs) loop ncs
  evaluate ($toppar.ncs_sta1_$ncc = $ncs_sta1_$ncc)
  evaluate ($toppar.ncs_end1_$ncc = $ncs_end1_$ncc)
  evaluate ($toppar.ncs_seg1_$ncc = $ncs_seg1_$ncc)
  evaluate ($toppar.ncs_sta2_$ncc = $ncs_sta2_$ncc)
  evaluate ($toppar.ncs_end2_$ncc = $ncs_end2_$ncc)
  evaluate ($toppar.ncs_seg2_$ncc = $ncs_seg2_$ncc)
  evaluate ($ncc = $ncc + 1)
end loop ncs

! Symmetry restraints
evaluate ($data.ksym = $ksym)
evaluate ($Data.flags.sym = $sym_on)
evaluate ($data.numc2sym = $numc2sym)
evaluate ($nsym=1)
while ($nsym <= $numc2sym) loop sym
  evaluate ($toppar.c2sym_sta1_$nsym = $c2sym_sta1_$nsym)
  evaluate ($toppar.c2sym_end1_$nsym = $c2sym_end1_$nsym)
  evaluate ($toppar.c2sym_seg1_$nsym = $c2sym_seg1_$nsym)
  evaluate ($toppar.c2sym_sta2_$nsym = $c2sym_sta2_$nsym)
  evaluate ($toppar.c2sym_end2_$nsym = $c2sym_end2_$nsym)
  evaluate ($toppar.c2sym_seg2_$nsym = $c2sym_seg2_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc3sym = $numc3sym)
evaluate ($nsym=1)
while ($nsym <=$numc3sym) loop sym
  evaluate ($toppar.c3sym_sta1_$nsym = $c3sym_sta1_$nsym)
  evaluate ($toppar.c3sym_end1_$nsym = $c3sym_end1_$nsym)
  evaluate ($toppar.c3sym_seg1_$nsym = $c3sym_seg1_$nsym)
  evaluate ($toppar.c3sym_sta2_$nsym = $c3sym_sta2_$nsym)
  evaluate ($toppar.c3sym_end2_$nsym = $c3sym_end2_$nsym)
  evaluate ($toppar.c3sym_seg2_$nsym = $c3sym_seg2_$nsym)
  evaluate ($toppar.c3sym_sta3_$nsym = $c3sym_sta3_$nsym)
  evaluate ($toppar.c3sym_end3_$nsym = $c3sym_end3_$nsym)
  evaluate ($toppar.c3sym_seg3_$nsym = $c3sym_seg3_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.nums3sym=$nums3sym)
evaluate ($nsym=1)
while ($nsym <=$nums3sym) loop sym
  evaluate ($toppar.s3sym_sta1_$nsym = $s3sym_sta1_$nsym)
  evaluate ($toppar.s3sym_end1_$nsym = $s3sym_end1_$nsym)
  evaluate ($toppar.s3sym_seg1_$nsym = $s3sym_seg1_$nsym)
  evaluate ($toppar.s3sym_sta2_$nsym = $s3sym_sta2_$nsym)
  evaluate ($toppar.s3sym_end2_$nsym = $s3sym_end2_$nsym)
  evaluate ($toppar.s3sym_seg2_$nsym = $s3sym_seg2_$nsym)
  evaluate ($toppar.s3sym_sta3_$nsym = $s3sym_sta3_$nsym)
  evaluate ($toppar.s3sym_end3_$nsym = $s3sym_end3_$nsym)
  evaluate ($toppar.s3sym_seg3_$nsym = $s3sym_seg3_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc4sym=$numc4sym)
evaluate ($nsym=1)
while ($nsym <=$numc4sym) loop sym
  evaluate ($toppar.c4sym_sta1_$nsym = $c4sym_sta1_$nsym)
  evaluate ($toppar.c4sym_end1_$nsym = $c4sym_end1_$nsym)
  evaluate ($toppar.c4sym_seg1_$nsym = $c4sym_seg1_$nsym)
  evaluate ($toppar.c4sym_sta2_$nsym = $c4sym_sta2_$nsym)
  evaluate ($toppar.c4sym_end2_$nsym = $c4sym_end2_$nsym)
  evaluate ($toppar.c4sym_seg2_$nsym = $c4sym_seg2_$nsym)
  evaluate ($toppar.c4sym_sta3_$nsym = $c4sym_sta3_$nsym)
  evaluate ($toppar.c4sym_end3_$nsym = $c4sym_end3_$nsym)
  evaluate ($toppar.c4sym_seg3_$nsym = $c4sym_seg3_$nsym)
  evaluate ($toppar.c4sym_sta4_$nsym = $c4sym_sta4_$nsym)
  evaluate ($toppar.c4sym_end4_$nsym = $c4sym_end4_$nsym)
  evaluate ($toppar.c4sym_seg4_$nsym = $c4sym_seg4_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc5sym=$numc5sym)
evaluate ($nsym=1)
while ($nsym <=$numc5sym) loop sym
  evaluate ($toppar.c5sym_sta1_$nsym = $c5sym_sta1_$nsym)
  evaluate ($toppar.c5sym_end1_$nsym = $c5sym_end1_$nsym)
  evaluate ($toppar.c5sym_seg1_$nsym = $c5sym_seg1_$nsym)
  evaluate ($toppar.c5sym_sta2_$nsym = $c5sym_sta2_$nsym)
  evaluate ($toppar.c5sym_end2_$nsym = $c5sym_end2_$nsym)
  evaluate ($toppar.c5sym_seg2_$nsym = $c5sym_seg2_$nsym)
  evaluate ($toppar.c5sym_sta3_$nsym = $c5sym_sta3_$nsym)
  evaluate ($toppar.c5sym_end3_$nsym = $c5sym_end3_$nsym)
  evaluate ($toppar.c5sym_seg3_$nsym = $c5sym_seg3_$nsym)
  evaluate ($toppar.c5sym_sta4_$nsym = $c5sym_sta4_$nsym)
  evaluate ($toppar.c5sym_end4_$nsym = $c5sym_end4_$nsym)
  evaluate ($toppar.c5sym_seg4_$nsym = $c5sym_seg4_$nsym)
  evaluate ($toppar.c5sym_sta5_$nsym = $c5sym_sta5_$nsym)
  evaluate ($toppar.c5sym_end5_$nsym = $c5sym_end5_$nsym)
  evaluate ($toppar.c5sym_seg5_$nsym = $c5sym_seg5_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym


evaluate ($data.numc6sym=$numc6sym)
evaluate ($nsym=1)
while ($nsym <=$numc6sym) loop sym
  evaluate ($toppar.c6sym_sta1_$nsym = $c6sym_sta1_$nsym)
  evaluate ($toppar.c6sym_end1_$nsym = $c6sym_end1_$nsym)
  evaluate ($toppar.c6sym_seg1_$nsym = $c6sym_seg1_$nsym)
  evaluate ($toppar.c6sym_sta2_$nsym = $c6sym_sta2_$nsym)
  evaluate ($toppar.c6sym_end2_$nsym = $c6sym_end2_$nsym)
  evaluate ($toppar.c6sym_seg2_$nsym = $c6sym_seg2_$nsym)
  evaluate ($toppar.c6sym_sta3_$nsym = $c6sym_sta3_$nsym)
  evaluate ($toppar.c6sym_end3_$nsym = $c6sym_end3_$nsym)
  evaluate ($toppar.c6sym_seg3_$nsym = $c6sym_seg3_$nsym)
  evaluate ($toppar.c6sym_sta4_$nsym = $c6sym_sta4_$nsym)
  evaluate ($toppar.c6sym_end4_$nsym = $c6sym_end4_$nsym)
  evaluate ($toppar.c6sym_seg4_$nsym = $c6sym_seg4_$nsym)
  evaluate ($toppar.c6sym_sta5_$nsym = $c6sym_sta5_$nsym)
  evaluate ($toppar.c6sym_end5_$nsym = $c6sym_end5_$nsym)
  evaluate ($toppar.c6sym_seg5_$nsym = $c6sym_seg5_$nsym)
  evaluate ($toppar.c6sym_sta6_$nsym = $c6sym_sta6_$nsym)
  evaluate ($toppar.c6sym_end6_$nsym = $c6sym_end6_$nsym)
  evaluate ($toppar.c6sym_seg6_$nsym = $c6sym_seg6_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

if ( data.numc2sym eq 6) then
!  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc3sym ne 0) then
!  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc4sym ne 0) then
!  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc5sym ne 0) then
!  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc6sym ne 0) then
!  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if


!Dihedrals, DNA and distance restraints
evaluate ($Data.dnarest =$dnarest_on)
evaluate ($Data.flags.cdih =$dihedrals_on)
evaluate ($Data.cdih.on =$dihedrals_on)
evaluate ($Data.ssdihed =$ssdihed)
evaluate ($Data.error_dih =$error_dih)
evaluate ($data.dihedrals.on=$dihedrals_on)
evaluate ($data.dihedrals_hot=$dihedrals_hot)
evaluate ($data.dihedrals_cool1=$dihedrals_cool1)
evaluate ($data.dihedrals_cool2=$dihedrals_cool2)
evaluate ($data.dihedrals_cool3=$dihedrals_cool3)
evaluate ($data.hbonds_on=$hbonds_on)

! RDC restraints
evaluate ($Data.flags.vean =  false)
evaluate ($Data.flags.xrdc =  false)
evaluate ($Data.flags.sani =  false)
evaluate ($data.numrdc=$numrdc)
evaluate ($ncc=1)
while ($ncc <=$data.numrdc) loop rdc
  if ($rdc_choice_$ncc = "VANGLE") then
    evaluate ($Data.flags.vean =  true)
  end if
  if ($rdc_choice_$ncc = "SANI") then
    evaluate ($Data.flags.sani =  true)
  end if
  if ($rdc_choice_$ncc = "XRDC") then
    evaluate ($Data.flags.xrdc =  true)
  end if
  evaluate ($data.rdc_choice_$ncc=$rdc_choice_$ncc)
  evaluate ($data.rdc_firstIt_$ncc=$rdc_firstIt_$ncc)
  evaluate ($data.rdc_lastIt_$ncc=$rdc_lastIt_$ncc)
  evaluate ($data.rdc_hot_$ncc=$rdc_hot_$ncc)
  evaluate ($data.rdc_cool1_$ncc=$rdc_cool1_$ncc)
  evaluate ($data.rdc_cool2_$ncc=$rdc_cool2_$ncc)
  evaluate ($data.rdc_cool3_$ncc=$rdc_cool3_$ncc)
  evaluate ($data.rdc_r_$ncc=$rdc_r_$ncc)
  evaluate ($data.rdc_d_$ncc=$rdc_d_$ncc)
  evaluate ($data.ini_bor_hot_$ncc=$ini_bor_hot_$ncc)
  evaluate ($data.ini_bor_cool1_$ncc=$ini_bor_cool1_$ncc)
  evaluate ($data.ini_bor_cool2_$ncc=$ini_bor_cool2_$ncc)
  evaluate ($data.ini_bor_cool3_$ncc=$ini_bor_cool3_$ncc)
  evaluate ($data.ini_cen_hot_$ncc=$ini_cen_hot_$ncc)
  evaluate ($data.ini_cen_cool1_$ncc=$ini_cen_cool1_$ncc)
  evaluate ($data.ini_cen_cool2_$ncc=$ini_cen_cool2_$ncc)
  evaluate ($data.ini_cen_cool3_$ncc=$ini_cen_cool3_$ncc)
  evaluate ($data.fin_bor_hot_$ncc=$fin_bor_hot_$ncc)
  evaluate ($data.fin_bor_cool1_$ncc=$fin_bor_cool1_$ncc)
  evaluate ($data.fin_bor_cool2_$ncc=$fin_bor_cool2_$ncc)
  evaluate ($data.fin_bor_cool3_$ncc=$fin_bor_cool3_$ncc)
  evaluate ($data.fin_cen_hot_$ncc=$fin_cen_hot_$ncc)
  evaluate ($data.fin_cen_cool1_$ncc=$fin_cen_cool1_$ncc)
  evaluate ($data.fin_cen_cool2_$ncc=$fin_cen_cool2_$ncc)
  evaluate ($data.fin_cen_cool3_$ncc=$fin_cen_cool3_$ncc)
  evaluate ($ncc=$ncc+1)
end loop rdc

! PCS restraints
evaluate ($Data.flags.xpcs =  false)
evaluate ($data.numpcs=$numpcs)
evaluate ($ncc=1)
while ($ncc <=$numpcs) loop pcs
  if ($pcs_choice_$ncc = "XPCS") then
    evaluate ($Data.flags.xpcs =  true)
  end if
  evaluate ($data.pcs_choice_$ncc=$pcs_choice_$ncc)
  evaluate ($data.pcs_firstIt_$ncc=$pcs_firstIt_$ncc)
  evaluate ($data.pcs_lastIt_$ncc=$pcs_lastIt_$ncc)
  evaluate ($data.pcs_hot_$ncc=$pcs_hot_$ncc)
  evaluate ($data.pcs_cool1_$ncc=$pcs_cool1_$ncc)
  evaluate ($data.pcs_cool2_$ncc=$pcs_cool2_$ncc)
  evaluate ($data.pcs_cool3_$ncc=$pcs_cool3_$ncc)
  evaluate ($data.pcs_r_$ncc=$pcs_r_$ncc)
  evaluate ($data.pcs_d_$ncc=$pcs_d_$ncc)
  evaluate ($ncc=$ncc+1)
end loop pcs

! DANI restraints
evaluate ($Data.flags.dani =  false)
evaluate ($data.numdani=$numdani)
evaluate ($ncc=1)
while ($ncc <=$numdani) loop dani
  if ($dan_choice_$ncc = "DANI") then
    evaluate ($Data.flags.dani =  true)
  end if
  evaluate ($data.dan_choice_$ncc=$dan_choice_$ncc)
  evaluate ($data.dan_firstIt_$ncc=$dan_firstIt_$ncc)
  evaluate ($data.dan_lastIt_$ncc=$dan_lastIt_$ncc)
  evaluate ($data.dan_hot_$ncc=$dan_hot_$ncc)
  evaluate ($data.dan_cool1_$ncc=$dan_cool1_$ncc)
  evaluate ($data.dan_cool2_$ncc=$dan_cool2_$ncc)
  evaluate ($data.dan_cool3_$ncc=$dan_cool3_$ncc)
  evaluate ($data.dan_tc_$ncc=$dan_tc_$ncc)
  evaluate ($data.dan_anis_$ncc=$dan_anis_$ncc)
  evaluate ($data.dan_r_$ncc=$dan_r_$ncc)
  evaluate ($data.dan_wh_$ncc=$dan_wh_$ncc)
  evaluate ($data.dan_wn_$ncc=$dan_wn_$ncc)
  evaluate ($ncc=$ncc+1)
end loop dani

! planarity restraints
evaluate ($Data.flags.plan =  false)

! distance restraints
evaluate ($Data.flags.noe  =  true)
evaluate ($data.scaling=$air_scaling)
evaluate ($data.totnoe_unamb=$tot_unamb)
evaluate ($data.unamb_firstit=$unamb_firstit)
evaluate ($data.unamb_lastit=$unamb_lastit)
evaluate ($data.unamb_hot=$unamb_hot)
evaluate ($data.unamb_cool1=$unamb_cool1)
evaluate ($data.unamb_cool2=$unamb_cool2)
evaluate ($data.unamb_cool3=$unamb_cool3)
evaluate ($data.noecv=$noecv)
evaluate ($data.ncvpart=$ncvpart)

evaluate ($data.totnoe_amb=$tot_amb)
evaluate ($data.amb_firstit=$amb_firstit)
evaluate ($data.amb_lastit=$amb_lastit)
evaluate ($data.amb_hot=$amb_hot)
evaluate ($data.amb_cool1=$amb_cool1)
evaluate ($data.amb_cool2=$amb_cool2)
evaluate ($data.amb_cool3=$amb_cool3)

evaluate ($data.hbond_firstit=$hbond_firstit)
evaluate ($data.hbond_lastit=$hbond_lastit)
evaluate ($data.hbond_hot=$hbond_hot)
evaluate ($data.hbond_cool1=$hbond_cool1)
evaluate ($data.hbond_cool2=$hbond_cool2)
evaluate ($data.hbond_cool3=$hbond_cool3)

evaluate ($data.mrswi_hot=$mrswi_hot)
evaluate ($data.mrswi_cool1=$mrswi_cool1)
evaluate ($data.mrswi_cool2=$mrswi_cool2)
evaluate ($data.mrswi_cool3=$mrswi_cool3)

evaluate ($data.rswi_hot=$rswi_hot)
evaluate ($data.rswi_cool1=$rswi_cool1)
evaluate ($data.rswi_cool2=$rswi_cool2)
evaluate ($data.rswi_cool3=$rswi_cool3)

evaluate ($data.masy_hot=$masy_hot)
evaluate ($data.masy_cool1=$masy_cool1)
evaluate ($data.masy_cool2=$masy_cool2)
evaluate ($data.masy_cool3=$masy_cool3)

evaluate ($data.asy_hot=$asy_hot)
evaluate ($data.asy_cool1=$asy_cool1)
evaluate ($data.asy_cool2=$asy_cool2)
evaluate ($data.asy_cool3=$asy_cool3)

evaluate ($data.ranair=$ranair)
if ($data.ranair eq true) then
  evaluate ($data.noecv = false)
end if
evaluate ($data.cmrest=$cmrest)
evaluate ($data.cmtight=$cmtight)
evaluate ($data.kcont=$kcont)
evaluate ($data.surfrest=$surfrest)
evaluate ($data.ksurf=$ksurf)


! radius of gydration restraints
evaluate ($data.flags.rg=$rgrest)
evaluate ($data.rgtarg=$rgtarg)
evaluate ($data.krg_hot=$krg_hot)
evaluate ($data.krg_cool1=$krg_cool1)
evaluate ($data.krg_cool2=$krg_cool2)
evaluate ($data.krg_cool3=$krg_cool3)
evaluate ($data.rgsele=$rgsele)

evaluate ($data.kzres=$kzres)
evaluate ($data.zresmax=$zresmax)
evaluate ($data.zresmin=$zresmin)

! keep or delete non-polar hydrogens
evaluate ($toppar.delenph=$delenph)


!Electrostatics:
evaluate ($Data.flags.dihed =$dihedflag)
evaluate ($Data.flags.elec0 =$elecflag_0)
evaluate ($Data.flags.elec1 =$elecflag_1)
evaluate ($Data.epsilon0 =$epsilon_0)
evaluate ($Data.epsilon1 =$epsilon_1)
evaluate ($Data.dielec0  =$dielec_0)
evaluate ($Data.dielec1  =$dielec_1)


!Interaction matrix:
evaluate ($nmol1=1)
while ($nmol1 <=$data.ncomponents) loop mol1
  evaluate ($nmol2=$nmol1 + 1)
  evaluate ($toppar.int_$nmol1_$nmol1 =$int_$nmol1_$nmol1)
  while ($nmol2 <=$data.ncomponents) loop mol2
    evaluate ($toppar.int_$nmol1_$nmol2 =$int_$nmol1_$nmol2)
    evaluate ($toppar.int_$nmol2_$nmol1 =$int_$nmol1_$nmol2)
    evaluate ($nmol2=$nmol2 + 1)
  end loop mol2
  evaluate ($nmol1 = $nmol1 + 1)
end loop mol1

!intermolecular contacts analysis
evaluate ($data.hb_dist=$dist_hb)
evaluate ($data.nb_dist=$dist_nb)


!water refinement
evaluate ($refine.firstwater=$firstwater)
evaluate ($refine.solvshell=$solvshell)
evaluate ($refine.keepwater=$keepwater)
!evaluate ($refine.waterrefine=$min($structures_1,waterrefine))
evaluate ($refine.solvent=$solvent)
evaluate ($refine.heatsteps=$waterheatsteps)
evaluate ($refine.steps=$watersteps)
evaluate ($refine.coolsteps=$watercoolsteps)


!for the non-bonded parameters (the section was taken out of
!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!):
if ($toppar.par_nonbonded eq "PROLSQ") then
    evaluate ($toppar.repel_radius = 1.0)
    evaluate ($toppar.repel_rcons = 20)
    evaluate ($toppar.repel_rexpo  = 4)
    evaluate ($toppar.repel_irexp  = 1)
elseif ($toppar.par_nonbonded eq "PARMALLH6") then
    evaluate ($toppar.repel_radius = 0.8)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
elseif ($toppar.par_nonbonded eq "OPLSX") then
    evaluate ($toppar.repel_radius = 0.0)
else        {...now the standard PARALLHDG parameters}
    evaluate ($toppar.repel_radius = 0.78)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
end if

! Water in rigid body docking
evaluate ($data.waterdock=$waterdock)
evaluate ($data.db_method=$db_method)
evaluate ($data.water_tokeep=$water_tokeep)
evaluate ($data.dnap_water_tokeep=$dnap_water_tokeep)
evaluate ($data.water_randfrac=$water_randfrac)
evaluate ($data.solvate_method=$solvate_method)
evaluate ($data.water_surfcutoff=$water_surfcutoff)
evaluate ($data.water_analysis=$water_analysis)
evaluate ($data.transwater=$transwater)
evaluate ($data.water_restraint_initial=$water_restraint_initial)
evaluate ($data.water_restraint_cutoff=$water_restraint_cutoff)
evaluate ($data.water_restraint_scale=$water_restraint_scale)
evaluate ($data.waterensemble=$waterensemble)

if ($data.waterdock eq true) then
!  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
  evaluate ($SaProtocol.initiosteps = 0)
  evaluate ($SaProtocol.cool1_steps = 0)
  evaluate ($refine.keepwater = true)
  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false
end if

! Centroid parameters
evaluate ($data.flags.centroids =$centroid_rest)
evaluate ($data.centroids.kscale =$centroid_kscale)
evaluate ($nchain = 0)
while ($nchain < $data.ncomponents) loop nloop1
    evaluate ($nchain = $nchain + 1)
    evaluate ($data.centroids.xcom_$nchain =$xcom_$nchain)
    evaluate ($data.centroids.ycom_$nchain =$ycom_$nchain)
    evaluate ($data.centroids.zcom_$nchain =$zcom_$nchain)
    evaluate ($data.centroids.ambi_$nchain =$ambi_$nchain)
end loop nloop1

if ($saprotocol.expand eq true) then
  evaluate ($data.flags.centroids = true)
end if

! Cryo-EM parameters
evaluate ($data.flags.em =$em_rest)
evaluate ($data.em.kscale =$em_kscale)
evaluate ($data.em.it0 =$em_it0)
evaluate ($data.em.it1 =$em_it1)
evaluate ($data.em.itw =$em_itw)
evaluate ($data.em.resolution =$em_resolution)
evaluate ($data.em.nx =$nx)
evaluate ($data.em.ny =$ny)
evaluate ($data.em.nz =$nz)
evaluate ($data.em.xlength =$xlength)
evaluate ($data.em.ylength =$ylength)
evaluate ($data.em.zlength =$zlength)

! Restraints
evaluate ($npart = $ncvpart)

!==================================================================!

if ( $log_level = "verbose" ) then
   set message=normal echo=on end
else
   set message=off echo=off end
end if

noe
  averaging  * sum
  potential  * soft
  scale      * 1.0
  sqconstant * 1.0
  sqexponent * 2
  soexponent * 1
  rswitch    * 1.0
  sqoffset   * 0.0
  asymptote  * 2.0
  msoexponent * 1
  masymptote  * -0.1
  mrswitch    * 1.0
  avexpo hbond 20
end

!fileexist $errfile end
!      if ($result eq false) then
!
!fileexist $ambig_fname end
!if ($result eq true) then
!    noe class ambi @@$ambig_fname end
!end if
!
!fileexist $unambig_fname end
!if ($result eq true) then
!    noe class dist @@$unambig_fname end
!end if

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python:
evaluate ($whichMD="torsion")
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python:
evaluate ($count = 1)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python:
evaluate ($file = "")
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!reads in structure, coordinates and parameter files

@RUN:protocols/read_struc.cns

flag include bond angle impr vdw end

if ($Data.flags.dihed eq true) then
  flag include dihed end
end if

do (fbeta=$Saprotocol.fbeta) (all)
do (mass=$Saprotocol.mass) (all)
do (mass=1000) (resn ani)
do (mass=1000) (resn xan)
do (mass=1000) (resn dan)

!evaluate ($end_count = $iterations.ini_count + $iterations.structures - 1)
!evaluate ($end_count = $iterations.ini_count + $structures_0)

! What is the purpose of this?
!if ($Data.noecv eq true) then
!  evaluate ($npart = 1 + mod($count,$Data.ncvpart))
!    evaluate ($fileseed="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".seed")
!  evaluate ($fileseed="NEWIT:complex" + "_" + encode($count) + ".seed")

!  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
evaluate ($fileseed=$output_pdb_filename - ".pdb" + ".seed")
set display=$fileseed end
display module(seed;npart)
display define (
display currentseed = $seed;
display currentpart = $npart;
display )
display evaluate (&seed=currentseed)
display evaluate (&npart=currentpart)
close $fileseed end

!else
!  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
!end if

!display $seed
set seed $seed end

!coor init end
!coor @@$file

! reinitialize the DUM residue
if ($Data.flags.centroids = true) then
    if ($iteration = 0) then
        @RUN:protocols/centroids_initialize.cns
    end if
end if

{* Find CoM of protein *}
show ave (x) (name CA or name BB or name C1')
evaluate ($xcent=$result)
show ave (y) (name CA or name BB or name C1')
evaluate ($ycent=$result)
show ave (z) (name CA or name BB or name C1')
evaluate ($zcent=$result)

coor select (not known and resn ani) end
if ($select gt 0) then
  coor @@$tensor_pdb

  {* Find CoM of protein and move tensor 100 A away *}
  show ave (x) (name CA or name BB or name C1')
  evaluate ($xcent=$result)
  show ave (y) (name CA or name BB or name C1')
  evaluate ($ycent=$result)
  show ave (z) (name CA or name BB or name C1')
  evaluate ($zcent=$result)
  do (x=x+$xcent+100) (resn ANI)
  do (y=y+$ycent+100) (resn ANI)
  do (z=z+$zcent+100) (resn ANI)
  evaluate ($rantens = true)
else
  evaluate ($rantens = false)
end if

coor select (not known and resn xan) end
if ($select gt 0) then
  coor @@$tensor_para_pdb
  evaluate ($rantens_para = true)
else
  evaluate ($rantens_para = false)
end if

coor select (not known and resn dan) end
if ($select gt 0) then
!  coor @@RUN:toppar/tensor_dani.pdb
  coor @@toppar/tensor_dani.pdb

  {* Find CoM of protein and move tensor 100 A away *}
  show ave (x) (name CA or name BB or name C1')
  evaluate ($xcent=$result)
  show ave (y) (name CA or name BB or name C1')
  evaluate ($ycent=$result)
  show ave (z) (name CA or name BB or name C1')
  evaluate ($zcent=$result)
  do (x=x+$xcent+100) (resn DAN)
  do (y=y+$ycent+100) (resn DAN)
  do (z=z+$zcent+100) (resn DAN)
  evaluate ($rantens_dani = true)
else
  evaluate ($rantens_dani = false)
end if

!catch possible bound water and set high T steps to 0
coor select ((resn WAT or resn HOH or resn TIP*)) end
if ($select gt 0) then
  evaluate ($SaProtocol.initiosteps = 0)
  evaluate ($SaProtocol.cool1_steps = 0)
  evaluate ($refine.keepwater = true)
end if

do (refx=x) (all)
do (refy=y) (all)
do (refz=z) (all)

!set the energy flags:
inline @RUN:protocols/setflags.cns

!read all the experimental Data:
evaluate ($lcc = 0)
set seed $seed end
set message=normal echo=on end
if ($data.waterdock eq false) then
    inline @RUN:protocols/read_data.cns
    if ($data.flags.em = true) then
!        @RUN:protocols/em_read_data.cns(Data=$data;)
        @RUN:protocols/em_read_data.cns
    end if

    if ($Data.flags.centroids = true) then
        if ($iteration = 0) then
            @RUN:protocols/centroids_set_restraints.cns
        end if
    end if
end if

{* ======================= reset coordinates and proceed *}

do (x = refx) (all)
do (y = refy) (all)
do (z = refz) (all)

inline @RUN:protocols/read_water1.cns
if ($data.waterdock eq true) then
  inline @RUN:protocols/water_rest.cns
  set seed $seed end
  set message=normal echo=on end
  inline @RUN:protocols/read_data.cns
end if

!set the energy flags:
inline @RUN:protocols/setflags.cns

{* random removal of restaints ================================== *}
if ($Data.noecv eq true) then
  set message=on echo=on end
  noe cv $npart ? end
else
  evaluate ($npart = 0)
end if

if ( $log_level = "verbose" ) then
   set message=normal echo=on end
else
   set message=off echo=off end
end if

!set the rdc coefficients:
evaluate ($nrdc=1)
while ($nrdc <= $data.numrdc) loop rdc
  evaluate ($cln = "rd" + encode($nrdc) )
  if ($Data.rdc_choice_$nrdc eq "SANI") then
    sani class $cln coeff 0.0 $Data.rdc_d_$nrdc $Data.rdc_r_$nrdc end
  end if
  if ($Data.rdc_choice_$nrdc eq "XRDC") then
    xrdc class $cln coeff $Data.rdc_d_$nrdc $Data.rdc_r_$nrdc end
  end if
  evaluate ($nrdc=$nrdc+1)
end loop rdc

!set the pcs coefficients:
evaluate ($npcs=1)
while ($npcs <= $data.numpcs) loop pcs
  if ($Data.pcs_choice_$npcs eq "XPCS") then
    evaluate ($cln = "pc"+encode($npcs) )
    xpcs class $cln coeff $Data.pcs_d_$npcs $Data.pcs_r_$npcs end
  end if
  evaluate ($npcs=$npcs+1)
end loop pcs

! set dani coefficients:
evaluate ($ndani=1)
while ($ndani <= $data.numdani) loop dani
  if ($Data.dan_choice_$ndani eq "DANI") then
    evaluate ($cln = "da"+encode($ndani) )
    dani class $cln coeff $Data.dan_tc_$ndani $Data.dan_anis_$ndani $Data.dan_r_$ndani $Data.dan_wh_$ndani $Data.dan_wn_$ndani end
  end if
  evaluate ($ndani=$ndani+1)
end loop dani


{* ============================================================== *}
eval ($anisotropy = false)
if ($Data.flags.sani eq true) then
  flag incl sani end
  eval ($anisotropy = true)
else
  flag excl sani end
end if

if ($Data.flags.xrdc eq true) then
  flag incl xrdc end
  eval ($anisotropy = true)
else
  flag excl xrdc end
end if

if ($Data.flags.xpcs eq true) then
  flag incl xpcs end
  eval ($anisotropy = true)
else
  flag excl xpcs end
end if

if ($Data.flags.vean eq true) then
  flag incl vean end
else
  flag excl vean end
end if

if ($Data.flags.dani eq true) then
  flag incl dani end
  eval ($anisotropy = true)
else
  flag excl dani end
end if

! determine whether the final models should be reoriented along their principal
! axes before writing to file in it0 and it1
eval($reorient = true)
if ($data.flags.zres = true) then
    eval($reorient = false)
elseif ($data.flags.em = true) then
    eval($reorient = false)
elseif ($data.flags.centroids = true) then
    eval($reorient = false)
end if
! also check for fixed molecules
evaluate ($ncount = 0)
while ($ncount < $data.ncomponents) loop orientmol
  evaluate ($ncount = $ncount + 1)
  if ($Toppar.fix_origin_$ncount eq true) then
    eval($reorient = false)
  end if
end loop orientmol


eval ($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop1
  eval($nchain1 = $nchain1 + 1)
  if ($Toppar.fix_origin_$nchain1 eq true) then
    eval($reorient = false)
  end if
end loop nloop1

evaluate ($numnoe = 0)

{*======================= semi-flexible SA refinement*}

  if ($saprotocol.expand eq TRUE ) then
    @RUN:protocols/centroids_initialize.cns
    @RUN:protocols/centroids_set_restraints.cns
    noe scale centroid $data.centroids.kscale end
    @RUN:protocols/expand.cns
    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + "_expand.pdb")
    write coordinates sele=(not resn DUM) output=$filename end
  end if

  !Make sure that at least as many distance restraints are successfully
  !read as the number of partitions for cross-validation
  evaluate ($numnoe = 999)
  noe ? end
  if ($NUMNOE = 0) then
    if ($Data.ncomponents > 1) then
      if ($Data.surfrest eq FALSE) then
        if ($Data.cmrest eq FALSE) then
          if ($Data.ranair eq FALSE) then
            if ($Data.flags.rg eq FALSE) then
              evaluate ($errfile = "RUN:WARNING")
              fileexist $errfile end
              if ($result eq false) then
                set display=$errfile end
                display TOTAL NUMBER OF DISTANCE RESTRAINTS FOR FLEXIBLE REFINEMENT IS ZERO!
                display CONTROL YOUR PARAMETER SETTINGS AND RESTRAINT DEFINITIONS
                close $errfile end
              end if
            end if
          end if
        end if
      end if
    end if
    evaluate ($Data.ncvpart = 1)
    evaluate ($Data.noecv = FALSE)
  end if

  if ($NUMNOE lt $Data.ncvpart) then
    noe part=1 end
    evaluate ($Data.ncvpart = 1)
    evaluate ($Data.noecv = FALSE)
  end if

  {*== check first for failed structures ==*}
  evaluate ($failure = false)
!  evaluate ($filefail="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".fail")
!  fileexist $filefail end
!  evaluate ($failure = $result)
!  evaluate ($failure = true)

  parameter
    bond  (resn WAT ) (resn WAT ) 1000 TOKEN
    angle (resn WAT ) (resn WAT ) (resn WAT ) 500 TOKEN
    bond  (resn HOH ) (resn HOH ) 1000 TOKEN
    angle (resn HOH ) (resn HOH ) (resn HOH ) 500 TOKEN
    bond  (resn TIP*) (resn TIP*) 1000 TOKEN
    angle (resn TIP*) (resn TIP*) (resn TIP*) 500 TOKEN
  end

  if ($Data.ranair eq true) then
    if ($Data.ncomponents > 2) then
      evaluate ($errfile = "RUN:FAILED")
      fileexist $errfile end
      if ($result eq false) then
        set display=$errfile end
        display ========= Unsupported option ===========
        display Random definition of AIRs with more than
        display two molecules currently unsupported
        display ========================================
        close $errfile end
      end if
      stop
    end if
    evaluate ($Data.noecv = false)
    noe
      reset
      nrestraints = 100000     ! allocate space for NOEs
      ceiling 1000
    end
    @RUN:protocols/contactairs.cns

    !Read back in hbond data
    if ($Data.hbond_lastit ge &iteration) then
      if ($Data.hbond_firstit le &iteration) then
        if ($Data.hbonds_on eq true) then
          fileexist $hbond_fname end
          if ($result eq true) then
!            noe @@$hbond_fname end
            noe @@$hbond_fname end
          end if
        end if
      end if
    end if

    noe
      averaging  * sum
      potential  * soft
      scale      * 1.0
      sqconstant * 1.0
      sqexponent * 2
      soexponent * 1
      rswitch    * 1.0
      sqoffset   * 0.0
      asymptote  * 2.0
      msoexponent * 1
      masymptote  * -0.1
      mrswitch    * 1.0
      avexpo hbond 20
    end
    inline @RUN:protocols/water_rest.cns
  end if

  if ($Data.flags.elec1 eq true) then
    flag include elec end
    if ($Data.dielec1 eq rdie) then
      parameter nbonds eps=$Data.epsilon1 rdie shift switch end end
      ! shift statement needed first to activate switch (CNS bug?)
    else
      parameter nbonds eps=$Data.epsilon1 cdie end end
    end if
    parameter nbonds ? end end
  else
    evaluate ($elec=0.0)
    flag exclude elec end
  end if

!end if

if ( $log_level = "verbose" ) then
  set message=normal echo=on end
else
  set message=off echo=off end
end if

evaluate ($ini_flt = 5.0)

@RUN:protocols/symmultimer.cns

if ($Data.flags.zres eq true ) then
  flag incl zhar end
  @RUN:protocols/zrestraining.cns
end if

if ($Data.cmrest eq true ) then
  @RUN:protocols/cm-restraints.cns
end if

! use contact airs rather than surface restraints at it1
if ($Data.surfrest eq true ) then
  @RUN:protocols/contactairs.cns
end if

if ($Data.dnarest eq true ) then
  @@$dna_rest_file
!  @RUN:data/sequence/dna-rna_restraints.def
end if

if ($Data.flags.rg eq true ) then
  collapse
    force  $Data.krg_hot
    target $Data.rgtarg
    sele   (not (resn ANI or resn XAN or resn TIP*))
  end
end if

if ($Data.ssdihed eq all ) then
  @@$protein_ss_rest_all
!  @RUN:protocols/protein-ss-restraints-all.def
end if
if ($Data.ssdihed eq alpha ) then
  @@$protein_ss_restraints_alpha
!  @RUN:protocols/protein-ss-restraints-alpha.def
end if
if ($Data.ssdihed eq alphabeta ) then
  @@$protein_ss_restraints_alpha_beta
!  @RUN:protocols/protein-ss-restraints-alpha-beta.def
end if

! get initial energy
energy end

coor copy end

if ($saprotocol.rotate180_it1 eq true) then
  evaluate ($rotiter = 2)  {* two iteration in rotloop1, rotation *}
else
  evaluate ($rotiter = 1)  {* only one iteration in rotloop1, no rotation *}
end if

evaluate ($nlcount = 0)  {* two iterations in rotloop1, first rotated *}
{* ================== Loop to sample 180 degrees rotated solutions if requested *}

while ($nlcount < $rotiter) loop rotloop1

  evaluate ($nlcount = $nlcount + 1)

  evaluate ($unamb_scale = $Data.unamb_hot)
  evaluate ($ambig_scale = $Data.amb_hot)
  evaluate ($hbond_scale = $Data.hbond_hot)

  noe
    scale dist $unamb_scale
    scale ambi $ambig_scale
    scale hbon $hbond_scale
  end

  if ($Data.flags.dihed eq true) then
    flag include dihed end
  end if

  if ($Data.scaling eq TRUE) then
    inline @RUN:protocols/set_noe_scale.cns
    energy end
    noe
      scale dist $Data.unamb_hot
      scale ambi $Data.amb_hot
    end
    energy end
  end if

  if ($Data.flags.sani eq true) then
    evaluate ($nrdc=1)
    while ($nrdc <= $data.numrdc) loop rdc
      evaluate ($cln = "rd"+encode($nrdc) )
      sani class $cln force $Data.rdc_hot_$nrdc end
      evaluate ($nrdc = $nrdc + 1)
    end loop rdc
    if ($rantens eq true) then
      @RUN:protocols/mini_tensor.cns
    end if
  end if

  evaluate ($paramin = false)
  if ($Data.flags.xrdc eq true) then
    evaluate ($nrdc=1)
    while ($nrdc <= $data.numrdc) loop rdc
      evaluate ($cln = "rd"+encode($nrdc) )
      xrdc class $cln force $Data.rdc_hot_$nrdc end
      evaluate ($nrdc = $nrdc + 1)
    end loop rdc
    evaluate ($paramin = true)
  end if

  if ($Data.flags.xpcs eq true) then
    evaluate ($npcs=1)
    while ($npcs <= $data.numpcs) loop pcs
      evaluate ($cln = "pc"+encode($npcs) )
      xpcs class $cln force $Data.pcs_hot_$npcs end
      evaluate ($paramin = true)
      evaluate ($npcs= $npcs + 1)
    end loop pcs
  end if

  if ($paramin eq TRUE) then
    if ($rantens_para eq true) then
      @RUN:protocols/mini_tensor_para.cns
    end if
  end if

  if ($Data.flags.dani eq true) then
    evaluate ($ndani=1)
    while ($ndani <= $data.numdani) loop dani
      evaluate ($cln = "da"+encode($ndani) )
      dani class $cln force $Data.dan_hot_$ndani end
      evaluate ($ndani = $ndani + 1)
    end loop dani
    if ($rantens_dani eq true) then
      @RUN:protocols/mini_tensor_dani.cns
    end if
  end if


  if ($nlcount = 2) then

    flag excl bond angl dihe impr zhar end

    evaluate ($kinter = $SaProtocol.inter_rigid)
    @RUN:protocols/scale_inter_only.cns

    eval($nchain1 = 0)
    while ($nchain1 < $data.ncomponents) loop nloop4
      eval($nchain1 = $nchain1 + 1)
      eval($nchain2 = $nchain1 )
      while ($nchain2 < $data.ncomponents) loop nloop3
        eval($nchain2 = $nchain2 + 1)
        @RUN:protocols/rotation180.cns
      end loop nloop3
    end loop nloop4

    inline @RUN:protocols/setflags.cns
    if ($Data.flags.elec1 eq true) then
      flag include elec end
    end if
    if ($Data.flags.dihed eq true) then
      flag include dihed end
    end if
    flag include bond angle impr vdw end

  end if

  igroup
    interaction  (not (resn ANI or resn DAN or resn XAN or resn SHA))
                 (not (resn ANI or resn DAN or resn XAN or resn SHA)) weight * 1 end
    interaction  (resn ANI or resn DAN or resn XAN or resn SHA)
                 (resn ANI or resn DAN or resn XAN or resn SHA) weight * 1 vdw 0.0 elec 0.0 end
  end

  energy end

  ! fix the residues describing the shape
  fix sele=(resn SHA) end

  ! fix the DUM residue for expand/refine
  if ($saprotocol.expand eq TRUE ) then
    fix sele=(name DUM) end
  end if

{* 0 ======================================= initial EM for flexible parts only *}

  if ($Data.flags.rg eq true ) then
    collapse force $Data.krg_hot end
  end if

  if ($SaProtocol.rigidtrans eq true) then
    @RUN:protocols/flex_segment_back.cns
    fix sele=((attr store5 = 0 or name OO or resn SHA) and not name H* and not (resn WAT or resn HOH or resn TIP*)) end
    minimize powell nstep=200 drop=10.0 nprint=25 end
    fix sele=(not all) end
  end if

  energy end

  do (refx = x) (all)
  do (refy = y) (all)
  do (refz = z) (all)

  do (harm = 0) (all)
  do (harm = 20) (name OO and not resn XAN)
  restraints harmonic exponent=2 end
  flag incl harm end

  ! fix the residues describing the shape
  fix sele=(resn SHA) end

  ! fix the DUM residue for expand/refine
  if ($saprotocol.expand eq TRUE ) then
    fix sele=(name DUM) end
  end if

  ! the following is added to avoid the generation of the torsion angle topology if not needed
  ! in cases where the number of steps is set to 0 (avoid issues with isolated atoms)
  eval ($torsiondone = false)
  if ($failure eq false) then
{* 1 ======================================= rigid body high temperature search*}
{* rigid bodies *}
    if ($data.flags.em = true) then
        if ($data.em.it1 = true) then
            flags include xref end
        end if
    end if

    if ($SaProtocol.initiosteps > 0) then
      @RUN:protocols/torsiontop.cns
      eval ($torsiondone = true)
      flags exclude dihed end
!      @RUN:protocols/sa_ltad_hightemp.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar)
      @RUN:protocols/sa_ltad_hightemp.cns
    end if

{* 2 ======================================= rigid body first slow cooling *}
{* rigid bodies only *}

    if ($Data.flags.rg eq true ) then
      collapse force $Data.krg_cool1 end
    end if

    if ($SaProtocol.cool1_steps > 0) then
      if ($torsiondone ne true) then
        @RUN:protocols/torsiontop.cns
        eval ($torsiondone = true)
      end if
      evaluate ($SaProtocol.tadfactor = 4)
!      @RUN:protocols/sa_ltad_cool1.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar)
      @RUN:protocols/sa_ltad_cool1.cns
    end if

{* 3 ======================================= second slow cooling *}
{* flexible side-chains and reduced time step *}

    if ($Data.flags.rg eq true ) then
      collapse force $Data.krg_cool2 end
    end if

    if ($Data.flags.dihed eq true) then flags include dihed end end if

    if ($SaProtocol.cool2_steps > 0) then
      if ($torsiondone eq true) then
        dyna tors topo reset end end
      end if
      @RUN:protocols/torsiontop_flex.cns
      eval ($torsiondone = true)
      evaluate ($SaProtocol.tadfactor = 1)
!      @RUN:protocols/sa_ltad_cool2.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar)
      @RUN:protocols/sa_ltad_cool2.cns
    end if

{* 4 ============================================ third slow cooling *}
{* flexible side-chains and backbone at interface and reduced time step *}

    if ($Data.flags.rg eq true ) then
      collapse force $Data.krg_cool3 end
    end if

    if ($SaProtocol.cool3_steps > 0) then
      if ($torsiondone eq true) then
        dyna tors topo reset end end
      end if
      @RUN:protocols/torsiontop_flex_back.cns
      eval ($torsiondone = true)
      evaluate ($SaProtocol.tadfactor = 1)
!      @RUN:protocols/sa_ltad_cool3.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar)
      @RUN:protocols/sa_ltad_cool3.cns
    end if

  end if

{* 5 =========================== final minimization *}

  if ($Data.scaling eq true) then
    inline @RUN:protocols/set_noe_scale.cns
    energy end
    noe
      scale dist $Data.unamb_cool3
      scale ambi $Data.amb_cool3
      scale hbon $Data.hbond_cool3
    end
    energy end
  end if

  @RUN:protocols/flex_segment_back.cns

  fix sele=((attr store5 = 0 or name OO or resn SHA) and not name H* and not (resn WAT or resn HOH or resn TIP* or resn XAN)) end
  minimize powell nstep=200 drop=10.0 nprint=25 end
  fix sele=(not all) end
  energy end

  if ($nlcount = 1) then
    coor swap end
    if ($torsiondone eq true) then
      if ($failure eq false) then
        dyna tors topo reset end end
      end if
    end if
  end if

end loop rotloop1

coor swap end

if ($saprotocol.rotate180_it1 eq true) then
  evaluate ($rotiter = 2)  {* two iteration in rotloop2, rotation *}
else
  evaluate ($rotiter = 1)  {* only one iteration in rotloop2, no rotation *}
end if

evaluate ($nlcount = 0)

{* ================== Loop to write 180 degrees rotated solutions if requested *}

while ($nlcount < $rotiter) loop rotloop2

  evaluate ($nlcount = $nlcount + 1)

{* ======================= calculate free molecules internal energy *}

  igroup
    interaction (not (resn ANI or resn DAN or resn XAN or resn SHA or resn WAT or resn HOH or resn TIP* or resn DUM))
                (not (resn ANI or resn DAN or resn XAN or resn SHA or resn WAT or resn HOH or resn TIP* or resn DUM)) weight * 1 end
  end

  do (refx=x) (all)
  do (refy=y) (all)
  do (refz=z) (all)

  fix sele=(resn ANI or resn DAN or resn XAN or resn SHA or resn WAT or resn HOH or resn TIP* or resn DMS) end

  flag excl noe dani sani vean xrdc xpcs coll cdih zhar end
  flag include bond angle dihe impr vdw end

  evaluate ($elec = 0.0)
  evaluate ($eintfree = 0.0)
  if ($Data.flags.elec1 eq true) then
    flag include elec end
  end if

  if ($Data.dielec1 eq rdie) then
    parameter nbonds eps=$Data.epsilon1 rdie shift switch end end
    ! shift statement needed first to activate switch (CNS bug?)
  else
    parameter nbonds eps=$Data.epsilon1 cdie end end
  end if
  parameter nbonds ? end end
  inline @RUN:protocols/calc_free-ene.cns

  fix sele=(not all) end

  do (x = refx) (all)
  do (y = refy) (all)
  do (z = refz) (all)

{* ===================== calculate complex internal energy *}

  evaluate ($kinter = 1.0)
  @RUN:protocols/scale_intra_only.cns

  flag include bond angle dihe impr vdw end

  evaluate ($elec = 0.0)
  evaluate ($eintcplx = 0.0)
  if ($Data.flags.elec1 eq true) then
    flag include elec end
  end if

  energy end

  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec)

{* ===================== calculate final energies and write structure *}
  evaluate ($cdih=0.0)
  flag incl noe cdih end
  if ($Data.flags.sani eq true) then
    flag incl sani end
  end if
  if ($Data.flags.xrdc eq true) then
    flag incl xrdc end
  end if
  if ($Data.flags.xpcs eq true) then
    flag incl xpcs end
  end if
  if ($Data.flags.dani eq true) then
    flag incl dani end
  end if
  if ($Data.flags.vean eq true) then
    flag incl vean end
  end if
  if ($Data.ncomponents > 1) then
    evaluate ($kinter = 1.0)
    @RUN:protocols/scale_inter_final.cns
  else
    @RUN:protocols/scale_intra_only.cns
  end if

  noe
    scale dist $Data.unamb_cool3
    scale ambi $Data.amb_cool3
    scale hbon 0.0
    scale symm 0.0
    scale cont 0.0
  end
  energy end
  evaluate ($eair= $noe)

  evaluate ($esym = 0.0)
  evaluate ($ncs = 0.0)
  evaluate ($zhar = 0.0)
  if ($Data.flags.sym  eq true) then
    noe reset nres= 200000 end
    @RUN:protocols/symmultimer.cns
    noe
      scale symm $Data.ksym
    end
    energy end
    evaluate ($esym = $noe)
    if ($Data.noecv eq true) then
      evaluate ($violations_test_noe=0)
      evaluate ($rms_test_noe=0.0)
      display Print out of cross-validated violations and rms not
      display possible in combination with symmetry restraints
      display CV values set therefore to 0
    end if
    noe reset end
    set message=normal echo=on end
    !read all the experimental Data:
!    @@RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count)
    @@RUN:protocols/read_noes.cns
!    if ( $log_level = verbose ) then
!      set message=normal echo=on end
!    else
!      set message=off echo=off end
!    end if
  else
    print threshold=0.3 noe
    evaluate ($rms_noe=$result)
    evaluate ($violations_noe=$violations)
    if ($Data.noecv eq true) then
      evaluate ($rms_test_noe=$test_rms)
      evaluate ($violations_test_noe=$test_violations)
    else
      evaluate ($rms_test_noe=0.0)
      evaluate ($violations_test_noe=0)
    end if
  end if

  if ($Data.dnarest eq true) then
    @@$dna_rest_file
!    @RUN:data/sequence/dna-rna_restraints.def
  end if

  energy end
  evaluate ($etot = $ener - $noe)
  evaluate ($noe = $eair)
  evaluate ($etot = $etot + $noe)

  ! get the local cross-correlation for EM-data
  if ($data.flags.em = true) then
!      @RUN:protocols/em_calc_lcc.cns(toppar=$toppar; data=$data; saprotocol=$saprotocol; lcc=$lcc;)
      @RUN:protocols/em_calc_lcc.cns
      flags exclude xref end
  end if


  evaluate ($Data.flags.dihed = false)
  if ($nlcount = 1) then
    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".pdb0")
  else
    evaluate ($num = $count + $iterations.structures)
    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($num) + ".pdb0")
  end if
  inline @RUN:protocols/print_coorheader.cns

  if ($reorient = true) then
    coor sele= (not name H* and not resn ANI and not resn XAN and not resn DAN) orient end
  end if

  if ($data.waterdock eq true) then
!    write coordinates sele=(not (resn WAT or resn HOH or resn TIP*)) output=$filename end
    write coordinates sele=(not (resn WAT or resn HOH or resn TIP*)) output=$output_pdb_filename end
    inline @RUN:protocols/waterdock_out1.cns
  else
!    write coordinates output=$filename end
    write coordinates output=$output_pdb_filename end
  end if

  coor swap end

end loop rotloop2

set message=normal echo=on end

 display OUTPUT: $output_pdb_filename

stop