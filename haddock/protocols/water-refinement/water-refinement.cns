! re_h2o.inp
!    Perform an explitic solvent (water) refinement
!
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!

!@RUN:protocols/initialize.cns(iteration=$iteration;)
!
!@NEWIT:water/iteration.cns(iteration=$iteration;)
!
!@RUN:run.cns(
!iteration =$iteration;
!filenames =$filenames;
!data      =$data;
!iterations=$iterations;
!saprotocol=$saprotocol;
!refine    =$refine;
!toppar    =$toppar;
!analysis  =$analysis;
!)

!evaluate ($log_level=verbose)

eval ($iteration = 2)

noe
  reset
  nrestraints = 12000000     ! allocate space for NOEs
  ceiling 1000
end

!==================================================================!
evaluate ($saprotocol.crossdock=$crossdock)
evaluate ($saprotocol.randorien=$randorien)
evaluate ($saprotocol.rebuildcplx=$rebuildcplx)
evaluate ($saprotocol.rigidmini=$rigidmini)
evaluate ($saprotocol.rigidtrans=$rigidtrans)
evaluate ($saprotocol.expand=$expand)
evaluate ($saprotocol.expansion=$expansion)
evaluate ($saprotocol.randangle=$randangle)

if ($saprotocol.expand eq true) then
  evaluate ($saprotocol.randorien = false)
  evaluate ($saprotocol.rigidmini = false)
end if

evaluate ($saprotocol.ntrials=$ntrials)
evaluate ($saprotocol.iniseed=$iniseed)
evaluate ($saprotocol.tadhigh_t=$tadhigh_t)
evaluate ($saprotocol.t1_init=$tadinit1_t)
evaluate ($saprotocol.t2_init=$tadinit2_t)
evaluate ($saprotocol.t3_init=$tadinit3_t)
evaluate ($saprotocol.t1_final=$tadfinal1_t)
evaluate ($saprotocol.t2_final=$tadfinal2_t)
evaluate ($saprotocol.t3_final=$tadfinal3_t)
evaluate ($saprotocol.inter_rigid=$inter_rigid)
evaluate ($saprotocol.inter_init_rigid=$init_rigid)
evaluate ($saprotocol.inter_fin_rigid=$fin_rigid)
evaluate ($saprotocol.inter_init_cool2=$init_cool2)
evaluate ($saprotocol.inter_fin_cool2=$fin_cool2)
evaluate ($saprotocol.inter_init_cool3=$init_cool3)
evaluate ($saprotocol.inter_fin_cool3=$fin_cool3)
!evaluate ($saprotocol.rotate180_it0=$rotate180_it0)
!evaluate ($saprotocol.rotate180_it1=$rotate180_it1)
evaluate ($saprotocol.tempstep=50)
evaluate ($saprotocol.timestep=$timestep)
evaluate ($saprotocol.tadfactor=$tadfactor)
evaluate ($saprotocol.emstepstrans=$emstepstrans)
evaluate ($saprotocol.initiosteps=$initiosteps)
evaluate ($saprotocol.cool1_steps=$cool1_steps)
evaluate ($saprotocol.cool2_steps=$cool2_steps)
evaluate ($saprotocol.cool3_steps=$cool3_steps)
evaluate ($saprotocol.fbeta=100)
evaluate ($saprotocol.mass=100)
evaluate ($fileroot="")
evaluate ($filenames.fileroot=$fileroot)
!evaluate ($filenames.template=$fileroot + "_1.pdb")

evaluate ($iterations.ini_count    =1)
!evaluate ($iterations.structures   =$structures_$iteration)
!evaluate ($iterations.keepstruct   =$keepstruct_$iteration)
evaluate ($iterations.w_vdw        =$w_vdw_$iteration)
evaluate ($iterations.w_elec       =$w_elec_$iteration)
evaluate ($iterations.w_dist       =$w_dist_$iteration)
evaluate ($iterations.w_rg         =$w_rg_$iteration)
evaluate ($iterations.w_sani       =$w_sani_$iteration)
evaluate ($iterations.w_xrdc       =$w_xrdc_$iteration)
evaluate ($iterations.w_xpcs       =$w_xpcs_$iteration)
evaluate ($iterations.w_dani       =$w_dani_$iteration)
evaluate ($iterations.w_vean       =$w_vean_$iteration)
evaluate ($iterations.w_cdih       =$w_cdih_$iteration)
evaluate ($iterations.w_sym        =$w_sym_$iteration)
evaluate ($iterations.w_zres       =$w_zres_$iteration)
evaluate ($iterations.w_bsa        =$w_bsa_$iteration)
evaluate ($iterations.w_deint      =$w_deint_$iteration)
evaluate ($iterations.w_desolv     =$w_desolv_$iteration)
!evaluate ($iterations.anastruc     =$anastruc_$iteration)
evaluate ($iterations.w_lcc        =$w_lcc_$iteration)


evaluate ($data.ncomponents=$ncomponents)
!
evaluate ($nmol=1)
while ($nmol <= $data.ncomponents) loop mol
!
!  !aa topology, linkage and parameters files
!  evaluate ($toppar.prot_top_$nmol=$prot_top_mol$nmol )
!  evaluate ($toppar.prot_link_$nmol=$prot_link_mol$nmol )
!  evaluate ($toppar.prot_par_$nmol=$prot_par_mol$nmol )
!
!  !coarse grained topology, linkage and parameters files
!  evaluate ($toppar.prot_cg_top_$nmol=$prot_cg_top_mol$nmol )
!  evaluate ($toppar.prot_cg_link_$nmol=$prot_cg_link_mol$nmol )
!  evaluate ($toppar.prot_cg_par_$nmol=$prot_cg_par_mol$nmol )
!
!  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid)
!  evaluate ($toppar.prot_coor_$nmol=$prot_coor_mol$nmol)
!  evaluate ($toppar.prot_root_$nmol=$prot_root_mol$nmol)
  evaluate ($toppar.fix_origin_$nmol=$fix_origin_mol$nmol)
  evaluate ($toppar.dna_$nmol=$dna_mol$nmol)
  evaluate ($toppar.cyclicpept_$nmol = $cyclicpept_mol$nmol)
  evaluate ($toppar.shape_$nmol = $shape_mol$nmol)
  evaluate ($toppar.cg_$nmol = $cg_mol$nmol)
  evaluate ($toppar.prot_segid_$nmol = $prot_segid_mol$nmol)

  !semi flexible segments
  evaluate ($toppar.nseg_$nmol = $nseg_$nmol)
  evaluate ($nseg = 1)
  while ($nseg <=$toppar.nseg_$nmol) loop seg
    evaluate ($toppar.start_seg_$nmol_$nseg = $start_seg_$nmol_$nseg)
    evaluate ($toppar.end_seg_$nmol_$nseg = $end_seg_$nmol_$nseg)
    evaluate ($nseg = $nseg + 1)
  end loop seg

  !fully flexible segments
  evaluate ($toppar.nfle_$nmol = $nfle_$nmol)
  evaluate ($nfle = 1)
  while ($nfle <=$toppar.nfle_$nmol) loop fle
    evaluate ($toppar.start_fle_$nmol_$nfle = $start_fle_$nmol_$nfle)
    evaluate ($toppar.end_fle_$nmol_$nfle = $end_fle_$nmol_$nfle)
    evaluate ($nfle = $nfle + 1)
  end loop fle
!
!  !histidine patches
  evaluate ($toppar.autohis = $autohis)
!  evaluate ($toppar.nhisd_$nmol = $numhisd_$nmol)
!  evaluate ($ncc=1)
!  while ($ncc <=$toppar.nhisd_$nmol) loop hisd
!    evaluate ($toppar.hisd_resid_$nmol_$ncc = $hisd_$nmol_$ncc)
!    evaluate ($ncc = $ncc + 1)
!  end loop hisd
!
!  evaluate ($toppar.nhise_$nmol = $numhise_$nmol)
!  evaluate ($ncc=1)
!  while ($ncc <=$toppar.nhise_$nmol) loop hisd
!    evaluate ($toppar.hise_resid_$nmol_$ncc = $hise_$nmol_$ncc)
!    evaluate ($ncc = $ncc + 1)
!  end loop hisd
!
  evaluate ($nmol = $nmol + 1)
end loop mol

! non-bonded parameter set to use
evaluate ($toppar.par_nonbonded = $par_nonbonded)

! z-restraining
evaluate ($Data.flags.zres = $zres_on)
evaluate ($data.numzres = $numzres)
evaluate ($ncc=1)
while ($ncc <= $numzres) loop zres
  evaluate ($toppar.zres_sta_$ncc = $zres_sta_$ncc)
  evaluate ($toppar.zres_end_$ncc = $zres_end_$ncc)
  evaluate ($toppar.zres_seg_$ncc = $zres_seg_$ncc)
  evaluate ($toppar.zres_type_$ncc = $zres_type_$ncc)
  evaluate ($ncc = $ncc + 1)
end loop zres

! NCS restraints
evaluate ($data.kncs = $kncs)
evaluate ($Data.flags.ncs = $ncs_on)
evaluate ($data.numncs = $numncs)
evaluate ($ncc=1)
while ($ncc <= $numncs) loop ncs
  evaluate ($toppar.ncs_sta1_$ncc = $ncs_sta1_$ncc)
  evaluate ($toppar.ncs_end1_$ncc = $ncs_end1_$ncc)
  evaluate ($toppar.ncs_seg1_$ncc = $ncs_seg1_$ncc)
  evaluate ($toppar.ncs_sta2_$ncc = $ncs_sta2_$ncc)
  evaluate ($toppar.ncs_end2_$ncc = $ncs_end2_$ncc)
  evaluate ($toppar.ncs_seg2_$ncc = $ncs_seg2_$ncc)
  evaluate ($ncc = $ncc + 1)
end loop ncs

! Symmetry restraints
evaluate ($data.ksym = $ksym)
evaluate ($Data.flags.sym = $sym_on)
evaluate ($data.numc2sym = $numc2sym)
evaluate ($nsym=1)
while ($nsym <= $numc2sym) loop sym
  evaluate ($toppar.c2sym_sta1_$nsym = $c2sym_sta1_$nsym)
  evaluate ($toppar.c2sym_end1_$nsym = $c2sym_end1_$nsym)
  evaluate ($toppar.c2sym_seg1_$nsym = $c2sym_seg1_$nsym)
  evaluate ($toppar.c2sym_sta2_$nsym = $c2sym_sta2_$nsym)
  evaluate ($toppar.c2sym_end2_$nsym = $c2sym_end2_$nsym)
  evaluate ($toppar.c2sym_seg2_$nsym = $c2sym_seg2_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc3sym = $numc3sym)
evaluate ($nsym=1)
while ($nsym <=$numc3sym) loop sym
  evaluate ($toppar.c3sym_sta1_$nsym = $c3sym_sta1_$nsym)
  evaluate ($toppar.c3sym_end1_$nsym = $c3sym_end1_$nsym)
  evaluate ($toppar.c3sym_seg1_$nsym = $c3sym_seg1_$nsym)
  evaluate ($toppar.c3sym_sta2_$nsym = $c3sym_sta2_$nsym)
  evaluate ($toppar.c3sym_end2_$nsym = $c3sym_end2_$nsym)
  evaluate ($toppar.c3sym_seg2_$nsym = $c3sym_seg2_$nsym)
  evaluate ($toppar.c3sym_sta3_$nsym = $c3sym_sta3_$nsym)
  evaluate ($toppar.c3sym_end3_$nsym = $c3sym_end3_$nsym)
  evaluate ($toppar.c3sym_seg3_$nsym = $c3sym_seg3_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.nums3sym=$nums3sym)
evaluate ($nsym=1)
while ($nsym <=$nums3sym) loop sym
  evaluate ($toppar.s3sym_sta1_$nsym = $s3sym_sta1_$nsym)
  evaluate ($toppar.s3sym_end1_$nsym = $s3sym_end1_$nsym)
  evaluate ($toppar.s3sym_seg1_$nsym = $s3sym_seg1_$nsym)
  evaluate ($toppar.s3sym_sta2_$nsym = $s3sym_sta2_$nsym)
  evaluate ($toppar.s3sym_end2_$nsym = $s3sym_end2_$nsym)
  evaluate ($toppar.s3sym_seg2_$nsym = $s3sym_seg2_$nsym)
  evaluate ($toppar.s3sym_sta3_$nsym = $s3sym_sta3_$nsym)
  evaluate ($toppar.s3sym_end3_$nsym = $s3sym_end3_$nsym)
  evaluate ($toppar.s3sym_seg3_$nsym = $s3sym_seg3_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc4sym=$numc4sym)
evaluate ($nsym=1)
while ($nsym <=$numc4sym) loop sym
  evaluate ($toppar.c4sym_sta1_$nsym = $c4sym_sta1_$nsym)
  evaluate ($toppar.c4sym_end1_$nsym = $c4sym_end1_$nsym)
  evaluate ($toppar.c4sym_seg1_$nsym = $c4sym_seg1_$nsym)
  evaluate ($toppar.c4sym_sta2_$nsym = $c4sym_sta2_$nsym)
  evaluate ($toppar.c4sym_end2_$nsym = $c4sym_end2_$nsym)
  evaluate ($toppar.c4sym_seg2_$nsym = $c4sym_seg2_$nsym)
  evaluate ($toppar.c4sym_sta3_$nsym = $c4sym_sta3_$nsym)
  evaluate ($toppar.c4sym_end3_$nsym = $c4sym_end3_$nsym)
  evaluate ($toppar.c4sym_seg3_$nsym = $c4sym_seg3_$nsym)
  evaluate ($toppar.c4sym_sta4_$nsym = $c4sym_sta4_$nsym)
  evaluate ($toppar.c4sym_end4_$nsym = $c4sym_end4_$nsym)
  evaluate ($toppar.c4sym_seg4_$nsym = $c4sym_seg4_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc5sym=$numc5sym)
evaluate ($nsym=1)
while ($nsym <=$numc5sym) loop sym
  evaluate ($toppar.c5sym_sta1_$nsym = $c5sym_sta1_$nsym)
  evaluate ($toppar.c5sym_end1_$nsym = $c5sym_end1_$nsym)
  evaluate ($toppar.c5sym_seg1_$nsym = $c5sym_seg1_$nsym)
  evaluate ($toppar.c5sym_sta2_$nsym = $c5sym_sta2_$nsym)
  evaluate ($toppar.c5sym_end2_$nsym = $c5sym_end2_$nsym)
  evaluate ($toppar.c5sym_seg2_$nsym = $c5sym_seg2_$nsym)
  evaluate ($toppar.c5sym_sta3_$nsym = $c5sym_sta3_$nsym)
  evaluate ($toppar.c5sym_end3_$nsym = $c5sym_end3_$nsym)
  evaluate ($toppar.c5sym_seg3_$nsym = $c5sym_seg3_$nsym)
  evaluate ($toppar.c5sym_sta4_$nsym = $c5sym_sta4_$nsym)
  evaluate ($toppar.c5sym_end4_$nsym = $c5sym_end4_$nsym)
  evaluate ($toppar.c5sym_seg4_$nsym = $c5sym_seg4_$nsym)
  evaluate ($toppar.c5sym_sta5_$nsym = $c5sym_sta5_$nsym)
  evaluate ($toppar.c5sym_end5_$nsym = $c5sym_end5_$nsym)
  evaluate ($toppar.c5sym_seg5_$nsym = $c5sym_seg5_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym


evaluate ($data.numc6sym=$numc6sym)
evaluate ($nsym=1)
while ($nsym <=$numc6sym) loop sym
  evaluate ($toppar.c6sym_sta1_$nsym = $c6sym_sta1_$nsym)
  evaluate ($toppar.c6sym_end1_$nsym = $c6sym_end1_$nsym)
  evaluate ($toppar.c6sym_seg1_$nsym = $c6sym_seg1_$nsym)
  evaluate ($toppar.c6sym_sta2_$nsym = $c6sym_sta2_$nsym)
  evaluate ($toppar.c6sym_end2_$nsym = $c6sym_end2_$nsym)
  evaluate ($toppar.c6sym_seg2_$nsym = $c6sym_seg2_$nsym)
  evaluate ($toppar.c6sym_sta3_$nsym = $c6sym_sta3_$nsym)
  evaluate ($toppar.c6sym_end3_$nsym = $c6sym_end3_$nsym)
  evaluate ($toppar.c6sym_seg3_$nsym = $c6sym_seg3_$nsym)
  evaluate ($toppar.c6sym_sta4_$nsym = $c6sym_sta4_$nsym)
  evaluate ($toppar.c6sym_end4_$nsym = $c6sym_end4_$nsym)
  evaluate ($toppar.c6sym_seg4_$nsym = $c6sym_seg4_$nsym)
  evaluate ($toppar.c6sym_sta5_$nsym = $c6sym_sta5_$nsym)
  evaluate ($toppar.c6sym_end5_$nsym = $c6sym_end5_$nsym)
  evaluate ($toppar.c6sym_seg5_$nsym = $c6sym_seg5_$nsym)
  evaluate ($toppar.c6sym_sta6_$nsym = $c6sym_sta6_$nsym)
  evaluate ($toppar.c6sym_end6_$nsym = $c6sym_end6_$nsym)
  evaluate ($toppar.c6sym_seg6_$nsym = $c6sym_seg6_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

if ( data.numc2sym eq 6) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc3sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc4sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc5sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc6sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if


!Dihedrals, DNA and distance restraints
evaluate ($Data.dnarest =$dnarest_on)
evaluate ($Data.flags.cdih =$dihedrals_on)
evaluate ($Data.cdih.on =$dihedrals_on)
evaluate ($Data.ssdihed =$ssdihed)
evaluate ($Data.error_dih =$error_dih)
evaluate ($data.dihedrals.on=$dihedrals_on)
evaluate ($data.dihedrals_hot=$dihedrals_hot)
evaluate ($data.dihedrals_cool1=$dihedrals_cool1)
evaluate ($data.dihedrals_cool2=$dihedrals_cool2)
evaluate ($data.dihedrals_cool3=$dihedrals_cool3)
evaluate ($data.hbonds_on=$hbonds_on)

! RDC restraints
evaluate ($Data.flags.vean =  false)
evaluate ($Data.flags.xrdc =  false)
evaluate ($Data.flags.sani =  false)
evaluate ($data.numrdc=$numrdc)
evaluate ($ncc=1)
while ($ncc <=$data.numrdc) loop rdc
  if ($rdc_choice_$ncc = "VANGLE") then
    evaluate ($Data.flags.vean =  true)
  end if
  if ($rdc_choice_$ncc = "SANI") then
    evaluate ($Data.flags.sani =  true)
  end if
  if ($rdc_choice_$ncc = "XRDC") then
    evaluate ($Data.flags.xrdc =  true)
  end if
  evaluate ($data.rdc_choice_$ncc=$rdc_choice_$ncc)
  evaluate ($data.rdc_firstIt_$ncc=$rdc_firstIt_$ncc)
  evaluate ($data.rdc_lastIt_$ncc=$rdc_lastIt_$ncc)
  evaluate ($data.rdc_hot_$ncc=$rdc_hot_$ncc)
  evaluate ($data.rdc_cool1_$ncc=$rdc_cool1_$ncc)
  evaluate ($data.rdc_cool2_$ncc=$rdc_cool2_$ncc)
  evaluate ($data.rdc_cool3_$ncc=$rdc_cool3_$ncc)
  evaluate ($data.rdc_r_$ncc=$rdc_r_$ncc)
  evaluate ($data.rdc_d_$ncc=$rdc_d_$ncc)
  evaluate ($data.ini_bor_hot_$ncc=$ini_bor_hot_$ncc)
  evaluate ($data.ini_bor_cool1_$ncc=$ini_bor_cool1_$ncc)
  evaluate ($data.ini_bor_cool2_$ncc=$ini_bor_cool2_$ncc)
  evaluate ($data.ini_bor_cool3_$ncc=$ini_bor_cool3_$ncc)
  evaluate ($data.ini_cen_hot_$ncc=$ini_cen_hot_$ncc)
  evaluate ($data.ini_cen_cool1_$ncc=$ini_cen_cool1_$ncc)
  evaluate ($data.ini_cen_cool2_$ncc=$ini_cen_cool2_$ncc)
  evaluate ($data.ini_cen_cool3_$ncc=$ini_cen_cool3_$ncc)
  evaluate ($data.fin_bor_hot_$ncc=$fin_bor_hot_$ncc)
  evaluate ($data.fin_bor_cool1_$ncc=$fin_bor_cool1_$ncc)
  evaluate ($data.fin_bor_cool2_$ncc=$fin_bor_cool2_$ncc)
  evaluate ($data.fin_bor_cool3_$ncc=$fin_bor_cool3_$ncc)
  evaluate ($data.fin_cen_hot_$ncc=$fin_cen_hot_$ncc)
  evaluate ($data.fin_cen_cool1_$ncc=$fin_cen_cool1_$ncc)
  evaluate ($data.fin_cen_cool2_$ncc=$fin_cen_cool2_$ncc)
  evaluate ($data.fin_cen_cool3_$ncc=$fin_cen_cool3_$ncc)
  evaluate ($ncc=$ncc+1)
end loop rdc

! PCS restraints
evaluate ($Data.flags.xpcs =  false)
evaluate ($data.numpcs=$numpcs)
evaluate ($ncc=1)
while ($ncc <=$numpcs) loop pcs
  if ($pcs_choice_$ncc = "XPCS") then
    evaluate ($Data.flags.xpcs =  true)
  end if
  evaluate ($data.pcs_choice_$ncc=$pcs_choice_$ncc)
  evaluate ($data.pcs_firstIt_$ncc=$pcs_firstIt_$ncc)
  evaluate ($data.pcs_lastIt_$ncc=$pcs_lastIt_$ncc)
  evaluate ($data.pcs_hot_$ncc=$pcs_hot_$ncc)
  evaluate ($data.pcs_cool1_$ncc=$pcs_cool1_$ncc)
  evaluate ($data.pcs_cool2_$ncc=$pcs_cool2_$ncc)
  evaluate ($data.pcs_cool3_$ncc=$pcs_cool3_$ncc)
  evaluate ($data.pcs_r_$ncc=$pcs_r_$ncc)
  evaluate ($data.pcs_d_$ncc=$pcs_d_$ncc)
  evaluate ($ncc=$ncc+1)
end loop pcs

! DANI restraints
evaluate ($Data.flags.dani =  false)
evaluate ($data.numdani=$numdani)
evaluate ($ncc=1)
while ($ncc <=$numdani) loop dani
  if ($dan_choice_$ncc = "DANI") then
    evaluate ($Data.flags.dani =  true)
  end if
  evaluate ($data.dan_choice_$ncc=$dan_choice_$ncc)
  evaluate ($data.dan_firstIt_$ncc=$dan_firstIt_$ncc)
  evaluate ($data.dan_lastIt_$ncc=$dan_lastIt_$ncc)
  evaluate ($data.dan_hot_$ncc=$dan_hot_$ncc)
  evaluate ($data.dan_cool1_$ncc=$dan_cool1_$ncc)
  evaluate ($data.dan_cool2_$ncc=$dan_cool2_$ncc)
  evaluate ($data.dan_cool3_$ncc=$dan_cool3_$ncc)
  evaluate ($data.dan_tc_$ncc=$dan_tc_$ncc)
  evaluate ($data.dan_anis_$ncc=$dan_anis_$ncc)
  evaluate ($data.dan_r_$ncc=$dan_r_$ncc)
  evaluate ($data.dan_wh_$ncc=$dan_wh_$ncc)
  evaluate ($data.dan_wn_$ncc=$dan_wn_$ncc)
  evaluate ($ncc=$ncc+1)
end loop dani

! planarity restraints
evaluate ($Data.flags.plan =  false)

! distance restraints
evaluate ($Data.flags.noe  =  true)
evaluate ($data.scaling=$air_scaling)
evaluate ($data.totnoe_unamb=$tot_unamb)
evaluate ($data.unamb_firstit=$unamb_firstit)
evaluate ($data.unamb_lastit=$unamb_lastit)
evaluate ($data.unamb_hot=$unamb_hot)
evaluate ($data.unamb_cool1=$unamb_cool1)
evaluate ($data.unamb_cool2=$unamb_cool2)
evaluate ($data.unamb_cool3=$unamb_cool3)
evaluate ($data.noecv=$noecv)
evaluate ($data.ncvpart=$ncvpart)

evaluate ($data.totnoe_amb=$tot_amb)
evaluate ($data.amb_firstit=$amb_firstit)
evaluate ($data.amb_lastit=$amb_lastit)
evaluate ($data.amb_hot=$amb_hot)
evaluate ($data.amb_cool1=$amb_cool1)
evaluate ($data.amb_cool2=$amb_cool2)
evaluate ($data.amb_cool3=$amb_cool3)

evaluate ($data.hbond_firstit=$hbond_firstit)
evaluate ($data.hbond_lastit=$hbond_lastit)
evaluate ($data.hbond_hot=$hbond_hot)
evaluate ($data.hbond_cool1=$hbond_cool1)
evaluate ($data.hbond_cool2=$hbond_cool2)
evaluate ($data.hbond_cool3=$hbond_cool3)

evaluate ($data.mrswi_hot=$mrswi_hot)
evaluate ($data.mrswi_cool1=$mrswi_cool1)
evaluate ($data.mrswi_cool2=$mrswi_cool2)
evaluate ($data.mrswi_cool3=$mrswi_cool3)

evaluate ($data.rswi_hot=$rswi_hot)
evaluate ($data.rswi_cool1=$rswi_cool1)
evaluate ($data.rswi_cool2=$rswi_cool2)
evaluate ($data.rswi_cool3=$rswi_cool3)

evaluate ($data.masy_hot=$masy_hot)
evaluate ($data.masy_cool1=$masy_cool1)
evaluate ($data.masy_cool2=$masy_cool2)
evaluate ($data.masy_cool3=$masy_cool3)

evaluate ($data.asy_hot=$asy_hot)
evaluate ($data.asy_cool1=$asy_cool1)
evaluate ($data.asy_cool2=$asy_cool2)
evaluate ($data.asy_cool3=$asy_cool3)

evaluate ($data.ranair=$ranair)
if ($data.ranair eq true) then
  evaluate ($data.noecv = false)
end if
evaluate ($data.cmrest=$cmrest)
evaluate ($data.cmtight=$cmtight)
evaluate ($data.kcont=$kcont)
evaluate ($data.surfrest=$surfrest)
evaluate ($data.ksurf=$ksurf)


! radius of gydration restraints
evaluate ($data.flags.rg=$rgrest)
evaluate ($data.rgtarg=$rgtarg)
evaluate ($data.krg_hot=$krg_hot)
evaluate ($data.krg_cool1=$krg_cool1)
evaluate ($data.krg_cool2=$krg_cool2)
evaluate ($data.krg_cool3=$krg_cool3)
evaluate ($data.rgsele=$rgsele)

evaluate ($data.kzres=$kzres)
evaluate ($data.zresmax=$zresmax)
evaluate ($data.zresmin=$zresmin)

! keep or delete non-polar hydrogens
evaluate ($toppar.delenph=$delenph)


!Electrostatics:
evaluate ($Data.flags.dihed =$dihedflag)
evaluate ($Data.flags.elec0 =$elecflag_0)
evaluate ($Data.flags.elec1 =$elecflag_1)
evaluate ($Data.epsilon0 =$epsilon_0)
evaluate ($Data.epsilon1 =$epsilon_1)
evaluate ($Data.dielec0  =$dielec_0)
evaluate ($Data.dielec1  =$dielec_1)


!Interaction matrix:
evaluate ($nmol1=1)
while ($nmol1 <=$data.ncomponents) loop mol1
  evaluate ($nmol2=$nmol1 + 1)
  evaluate ($toppar.int_$nmol1_$nmol1 =int_$nmol1_$nmol1)
  while ($nmol2 <=$data.ncomponents) loop mol2
    evaluate ($toppar.int_$nmol1_$nmol2 =$int_$nmol1_$nmol2)
    evaluate ($toppar.int_$nmol2_$nmol1 =$int_$nmol1_$nmol2)
    evaluate ($nmol2=$nmol2 + 1)
  end loop mol2
  evaluate ($nmol1 = $nmol1 + 1)
end loop mol1

!intermolecular contacts analysis
evaluate ($data.hb_dist=$dist_hb)
evaluate ($data.nb_dist=$dist_nb)


!water refinement
evaluate ($refine.firstwater=$firstwater)
evaluate ($refine.solvshell=$solvshell)
evaluate ($refine.keepwater=$keepwater)
!evaluate ($refine.waterrefine=$min($structures_1,waterrefine))
evaluate ($refine.solvent=$solvent)
evaluate ($refine.heatsteps=$waterheatsteps)
evaluate ($refine.steps=$watersteps)
evaluate ($refine.coolsteps=$watercoolsteps)


!for the non-bonded parameters (the section was taken out of
!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!):
if ($toppar.par_nonbonded eq "PROLSQ") then
    evaluate ($toppar.repel_radius = 1.0)
    evaluate ($toppar.repel_rcons = 20)
    evaluate ($toppar.repel_rexpo  = 4)
    evaluate ($toppar.repel_irexp  = 1)
elseif ($toppar.par_nonbonded eq "PARMALLH6") then
    evaluate ($toppar.repel_radius = 0.8)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
elseif ($toppar.par_nonbonded eq "OPLSX") then
    evaluate ($toppar.repel_radius = 0.0)
else        {...now the standard PARALLHDG parameters}
    evaluate ($toppar.repel_radius = 0.78)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
end if

! Water in rigid body docking
evaluate ($data.waterdock=$waterdock)
evaluate ($data.db_method=$db_method)
evaluate ($data.water_tokeep=$water_tokeep)
evaluate ($data.dnap_water_tokeep=$dnap_water_tokeep)
evaluate ($data.water_randfrac=$water_randfrac)
evaluate ($data.solvate_method=$solvate_method)
evaluate ($data.water_surfcutoff=$water_surfcutoff)
evaluate ($data.water_analysis=$water_analysis)
evaluate ($data.transwater=$transwater)
evaluate ($data.water_restraint_initial=$water_restraint_initial)
evaluate ($data.water_restraint_cutoff=$water_restraint_cutoff)
evaluate ($data.water_restraint_scale=$water_restraint_scale)
evaluate ($data.waterensemble=$waterensemble)

if ($data.waterdock eq true) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
  evaluate ($SaProtocol.initiosteps = 0)
  evaluate ($SaProtocol.cool1_steps = 0)
  evaluate ($refine.keepwater = true)
  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false
end if

! Centroid parameters
evaluate ($data.flags.centroids =$centroid_rest)
evaluate ($data.centroids.kscale =$centroid_kscale)
evaluate ($nchain = 0)
while ($nchain < $data.ncomponents) loop nloop1
    evaluate ($nchain = $nchain + 1)
    evaluate ($data.centroids.xcom_$nchain =$xcom_$nchain)
    evaluate ($data.centroids.ycom_$nchain =$ycom_$nchain)
    evaluate ($data.centroids.zcom_$nchain =$zcom_$nchain)
    evaluate ($data.centroids.ambi_$nchain =$ambi_$nchain)
end loop nloop1

if ($saprotocol.expand eq true) then
  evaluate ($data.flags.centroids = true)
end if

! Cryo-EM parameters
evaluate ($data.flags.em =$em_rest)
evaluate ($data.em.kscale =$em_kscale)
evaluate ($data.em.it0 =$em_it0)
evaluate ($data.em.it1 =$em_it1)
evaluate ($data.em.itw =$em_itw)
evaluate ($data.em.resolution =$em_resolution)
evaluate ($data.em.nx =$nx)
evaluate ($data.em.ny =$ny)
evaluate ($data.em.nz =$nz)
evaluate ($data.em.xlength =$xlength)
evaluate ($data.em.ylength =$ylength)
evaluate ($data.em.zlength =$zlength)

! Restraints
evaluate ($npart = $ncvpart)

if ( $log_level = "verbose" ) then
   set message=normal echo=on end
else
   set message=off echo=off end
end if

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python: 
evaluate ($count = 1)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python: 
evaluate ($file = "")
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!reads in structure, coordinates and parameter files
@RUN:protocols/read_struc.cns

!set the energy flags:
inline @RUN:protocols/setflags.cns

evaluate ($Data.flags.zres = false)
evaluate ($zhar = 0.0)

evaluate ($Data.flags.elec = true)
flags include elec end

!load the solvent topology files:
!topology  @@RUN:toppar/water-allhdg5-4.top end

if ($Data.noecv eq true) then
  evaluate ($fileseed=$file - ".pdb" + ".seed")
  @@$fileseed(seed=$seed;npart=$npart)
else
  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
end if
set seed $seed end

! read coordinate and copy to reference coordinate set
!coor @@$file
coor copy end

{*== check first for failed structures ==*}
evaluate ($failure = false)
!evaluate ($filefail= "NEWIT:water/" + $file - "PREVIT:" - ".pdb" + "w.fail")
!fileexist $filefail end
!evaluate ($failure = $result)

! check for CG molecule
eval($nchain1= 1)
eval($coarse = false)
while ($nchain1 <= $data.ncomponents) loop cloop0
  if ($toppar.cg_$nchain1 = true) then
    eval($coarse = true)
  end if
  eval($nchain1 = $nchain1 + 1)
end loop cloop0

! perform the morphing to all atoms model if needed
if ($coarse eq true) then
  inline @RUN:protocols/read_struc-cg.cns
  inline @RUN:protocols/cg-to-aa.cns

  ! reset non-bonded parameters to all atoms defaults
  parameter
    nbonds
      nbxmod=5 atom cdie shift
      cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=1.0 e14fac=0.4 inhibit 0.25
      wmin=0.5 tolerance  0.5
    end
  end

end if

if ($data.waterdock eq true) then
 inline @RUN:protocols/read_water1.cns
end if

if ($Data.flags.sani eq true) then
   flag incl sani end
   coor select (not known and resn ani) end
   if ($select gt 0) then 
     coor @@$tensor_pdb

     {* Find CoM of protein and move tensor 100 A away *}
     show ave (x) (name CA or name BB or name C1') 
     evaluate ($xcent=$result)
     show ave (y) (name CA or name BB or name C1') 
     evaluate ($ycent=$result)
     show ave (z) (name CA or name BB or name C1') 
     evaluate ($zcent=$result)
     do (x=x+$xcent+100) (resn ANI)
     do (y=y+$ycent+100) (resn ANI)
     do (z=z+$zcent+100) (resn ANI)

     evaluate ($rantens = true)
   else
     evaluate ($rantens = false)
   end if

   {* Harmonic restraints to keep it far away *}
   do (refx=x) (all)
   do (refy=y) (all)
   do (refz=z) (all)
   do (harmonic=20.0)(resn ANI and name OO)
   do (harmonic=0.0) (resn ANI and name X )
   do (harmonic=0.0) (resn ANI and name Y )
   do (harmonic=0.0) (resn ANI and name Z )
   do (harmonic=0.0) (not (resn ANI))
   restraints harmonic exponent=2 end
   flags include harm end
end if

evaluate ($xanmin = false)
if ($Data.flags.xrdc eq true) then
  evaluate ($xanmin = true)
  flag incl xrdc end
end if
if ($Data.flags.xpcs eq true) then
  evaluate ($xanmin = true)
  flag incl xpcs end
end if
if ($xanmin eq true) then
   coor select (not known and resn xan) end
   if ($select gt 0) then 
     coor @@$tensor_para_pdb

     {* Find CoM of protein and move tensor 100 A away *}
     show ave (x) (name CA or name BB or name C1') 
     evaluate ($xcent=$result)
     show ave (y) (name CA or name BB or name C1') 
     evaluate ($ycent=$result)
     show ave (z) (name CA or name BB or name C1') 
     evaluate ($zcent=$result)
     do (x=x+$xcent+100) (resn XAN)
     do (y=y+$ycent+100) (resn XAN)
     do (z=z+$zcent+100) (resn XAN)
     evaluate ($rantens_para = true)
   else
     evaluate ($rantens_para = false)
   end if
end if

if ($Data.flags.dani eq true) then
   flag incl dani end
   coor select (not known and resn DAN) end
   if ($select gt 0) then 
!     coor @@RUN:toppar/tensor_dani.pdb
     coor @@$tensor_dani_pdb

     {* Find CoM of protein and move tensor 100 A away *}
     show ave (x) (name CA or name BB or name C1') 
     evaluate ($xcent=$result)
     show ave (y) (name CA or name BB or name C1') 
     evaluate ($ycent=$result)
     show ave (z) (name CA or name BB or name C1') 
     evaluate ($zcent=$result)
     do (x=x+$xcent+100) (resn DAN)
     do (y=y+$ycent+100) (resn DAN)
     do (z=z+$zcent+100) (resn DAN)

     evaluate ($rantens_dani = true)
   else
     evaluate ($rantens_dani = false)
   end if

   {* Harmonic restraints to keep it far away *}
   do (refx=x) (all)
   do (refy=y) (all)
   do (refz=z) (all)
   do (harmonic=20.0)(resn DAN and name OO)
   do (harmonic=0.0) (resn DAN and name X )
   do (harmonic=0.0) (resn DAN and name Y )
   do (harmonic=0.0) (resn DAN and name Z )
   do (harmonic=0.0) (not (resn ANI or resn DAN))
   restraints harmonic exponent=2 end
   flags include harm end
end if

if ($Data.flags.rg eq true ) then
  collapse
    force  $Data.krg_cool3
    target $Data.rgtarg
    sele   (not (resn ANI or resn XAN or resn WAT or resn HOH or resn TIP3))
  end
end if

do (refx = x) (all)
do (refy = y) (all)
do (refz = z) (all)

{*== check if water refinement should be performed ==*}
if ($refine.firstwater eq "yes") then
  if ($refine.solvshell eq true) then
    if ($failure eq false) then
      ! generate water layer
      do (segid = "PROT") (segid "    ")
      @RUN:protocols/generate_water.cns
      do (segid = "    ") (segid "PROT")
    end if
  else
!    parameter nbonds eps=$Data.epsilon end end
    parameter nbonds eps=$Data.epsilon1 end end
  end if
end if

set seed $seed end
set message=normal echo=on end
inline @RUN:protocols/read_data.cns

! read EM-data
if ($data.flags.em = true) then
!    @RUN:protocols/em_read_data.cns(data=$data;)
    @RUN:protocols/em_read_data.cns
    if ($data.em.itw = true) then
        flags include xref end
    end if
end if

if ($refine.solvshell eq true) then
  inline @RUN:protocols/water_rest.cns
end if
     
if ($Data.ranair eq true) then
  if ($Data.ncomponents > 2) then
    display ========= Unsupported option ===========
    display Random definition of AIRs with more than
    display two molecules currently unsupported
    display ========================================
    stop
  end if
  evaluate ($Data.noecv = false)
  noe
    reset
    nrestraints = 100000     ! allocate space for NOEs
    ceiling 1000
  end
!  @RUN:protocols/contactairs.cns

  !Read back in hbond data
  if ($Data.hbond_lastit ge &iteration) then
      if ($Data.hbond_firstit le &iteration) then
        if ($Data.hbonds_on eq true) then
          noe @@$hbond_fname end
        end if
      end if
  end if

  noe
    averaging  * sum
    potential  * soft
    scale      * 1.0
    sqconstant * 1.0
    sqexponent * 2
    soexponent * 1
    rswitch    * 1.0
    sqoffset   * 0.0
    asymptote  * 2.0
    msoexponent * 1
    masymptote  * -0.1
    mrswitch    * 1.0
    avexpo hbond 20
  end
  inline @RUN:protocols/water_rest.cns
end if

{* random removal of restaints ================================== *}
!Make sure that at least as many distance restraints are successfully
!read as the number of partitions for cross-validation
evaluate ($numnoe = 999)
noe ? end
if ($NUMNOE = 0) then
  evaluate ($Data.ncvpart = 1)
  evaluate ($Data.noecv = FALSE)
end if

if ($NUMNOE lt $Data.ncvpart) then
  noe part=1 end
  evaluate ($Data.ncvpart = 1)
  evaluate ($Data.noecv = FALSE)
end if

if ($Data.noecv eq true) then
  set message=on echo=on end
  noe cv $npart ? end
else
  evaluate ($npart = 0)
end if

if ( $log_level = "verbose" ) then
   set message=normal echo=on end
else
   set message=off echo=off end
end if

if ($Data.flags.sani eq true) then
   flag incl sani end
else
  flag excl sani end
end if

if ($Data.flags.xrdc eq true) then
   flag incl xrdc end
else
   flag excl xrdc end
end if

if ($Data.flags.xpcs eq true) then
   flag incl xpcs end
else
   flag excl xpcs end
end if

if ($Data.flags.dani eq true) then
   flag incl dani end
else
  flag excl dani end
end if

if ($Data.flags.vean eq true) then
   flag incl vean end
else
  flag excl vean end
end if

!set the rdc coefficients:
evaluate ($nrdc=1)
while ($nrdc <= $data.numrdc) loop rdc
  evaluate ($cln = "rd" + encode($nrdc) )
  if ($Data.rdc_choice_$nrdc eq "SANI") then
    sani class $cln coeff 0.0 $Data.rdc_d_$nrdc $Data.rdc_r_$nrdc end
    sani class $cln force $data.rdc_cool3_$nrdc end
  end if
  if ($Data.rdc_choice_$nrdc eq "VANGLE") then
    vean class $cln force $Data.fin_bor_cool3_$nrdc $Data.fin_cen_cool3_$nrdc end
  end if
  if ($Data.rdc_choice_$nrdc eq "XRDC") then
    xrdc class $cln coeff $Data.rdc_d_$nrdc $Data.rdc_r_$nrdc end
    xrdc class $cln force $data.rdc_cool3_$nrdc end
  end if
  evaluate ($nrdc=$nrdc+1)
end loop rdc

!set the pcs coefficients:
evaluate ($npcs=1)
while ($npcs <= $data.numpcs) loop pcs
  evaluate ($cln = "pc" + encode($npcs) )
  if ($Data.pcs_choice_$npcs eq "XPCS") then
    xpcs class $cln coeff $Data.pcs_d_$npcs $Data.pcs_r_$npcs end
    xpcs class $cln force $data.pcs_cool3_$npcs end
  end if
  evaluate ($npcs=$npcs+1)
end loop pcs

! set dani coefficients:
evaluate ($ndani=1)
while ($ndani <= $data.numdani) loop dani
  evaluate ($cln = "da" + encode($ndani) )
  if ($Data.dan_choice_$ndani eq "DANI") then
    dani class $cln coeff $Data.dan_tc_$ndani $Data.dan_anis_$ndani $Data.dan_r_$ndani $Data.dan_wh_$ndani $Data.dan_wn_$ndani end
    dani class $cln force $data.dan_cool3_$ndani end
  end if
  evaluate ($ndani=$ndani+1)
end loop dani


@RUN:protocols/symmultimer.cns
 
if ($Data.scaling eq true) then 
  inline @RUN:protocols/set_noe_scale.cns
end if
igroup
  interaction (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end
  interaction (resn ANI or resn DAN or resn XAN)
              (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end
end

noe 
    rswitch ambi $Data.Rswi_cool3 
    rswitch dist $Data.Rswi_cool3
    rswitch hbon $Data.Rswi_cool3

    mrswitch ambi $Data.mRswi_cool3 
    mrswitch dist $Data.mRswi_cool3
    mrswitch hbon $Data.mRswi_cool3

    asym ambi $Data.asy_cool3
    asym dist $Data.asy_cool3
    asym hbon $Data.asy_cool3

    masym ambi $Data.masy_cool3 
    masym dist $Data.masy_cool3
    masym hbon $Data.masy_cool3

    scale ambi $Data.amb_cool3 
    scale dist $Data.unamb_cool3
    scale hbon $Data.hbond_cool3
end

restraints dihedral 
    scale=$Data.dihedrals_cool3
end 

if ($Data.dnarest eq true) then
  @@$dna_rest_file
!  @RUN:data/sequence/dna-rna_restraints.def
end if

if ($Data.flags.sani eq true) then
  if ($rantens eq true) then
    @RUN:protocols/mini_tensor.cns
  end if
end if

evaluate ($xanmin = false)
if ($Data.flags.xrdc eq true) then
  evaluate ($xanmin = true)
end if
if ($Data.flags.xpcs eq true) then
  evaluate ($xanmin = true)
end if
if ($xanmin eq true) then
!  if ($rantens_para eq true) then
    @RUN:protocols/mini_tensor_para.cns
!  end if
end if

if ($Data.flags.dani eq true) then
  if ($rantens_dani eq true) then
    @RUN:protocols/mini_tensor_dani.cns
  end if
end if

if ($Data.ssdihed eq all ) then
  @@$protein_ss_rest_all
!  inline @RUN:protocols/protein-ss-restraints-all.def
  flag incl cdih end
end if
if ($Data.ssdihed eq alpha ) then
  @@$protein_ss_restraints_alpha
!  inline @RUN:protocols/protein-ss-restraints-alpha.def
  flag incl cdih end
end if
if ($Data.ssdihed eq alphabeta ) then
  @@$protein_ss_restraints_alpha_beta
!  inline @RUN:protocols/protein-ss-restraints-alpha-beta.def
  flag incl cdih end
end if

energy end

{*== check if water refinement should be performed ==*}
if ($refine.firstwater eq "yes") then

! since we do not use SHAKe, increase the water bond angle energy constant
parameter
  bond  (resn WAT ) (resn WAT ) 1000 TOKEN
  angle (resn WAT ) (resn WAT ) (resn WAT ) 500 TOKEN
  bond  (resn HOH ) (resn HOH ) 1000 TOKEN
  angle (resn HOH ) (resn HOH ) (resn HOH ) 500 TOKEN
  bond  (resn TIP*) (resn TIP*) 1000 TOKEN
  angle (resn TIP*) (resn TIP*) (resn TIP*) 500 TOKEN
end

! fix the protein for initial minimization
fix sele = (not (resn WAT or resn HOH or resn TIP*)) end

! fix rigid molecules including their waters if present
evaluate($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop1
  evaluate($nchain1 = $nchain1 + 1)
  evaluate($fcounter=0)
  if ($Toppar.nseg_$nchain1 = 0) then
     display NO FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1
     display FIXING IT
     fix sele = (segid $Toppar.prot_segid_$nchain1 and not name H*) end
  end if
end loop nloop1

! fix the shape
fix sele = (resn SHA) end

minimize powell nstep=40 drop=100 end

! release protein and restrain harmonically
fix sele = (not all) end

! fix the shape
fix sele = (resn SHA) end

! fix rigid molecules 
evaluate($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop1
  evaluate($nchain1 = $nchain1 + 1)
  evaluate($fcounter=0)
  if ($Toppar.nseg_$nchain1 = 0) then
     display NO FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1
     display FIXING IT
     fix sele = (segid $Toppar.prot_segid_$nchain1 and not name H*) end
  end if
end loop nloop1

do (refx=x) (all)
do (refy=y) (all)
do (refz=z) (all)
restraints harmonic 
   exponent = 2
end
do (harm = 0)  (all)
do (harm = 5) (not name h* and not (resn WAT or resn HOH or resn TIP*))
do (harmonic=20.0)(resn ANI and name OO)
do (harmonic=0.0) (resn ANI and name X )
do (harmonic=0.0) (resn ANI and name Y )
do (harmonic=0.0) (resn ANI and name Z )
do (harmonic=20.0)(resn DAN and name OO)
do (harmonic=0.0) (resn DAN and name X )
do (harmonic=0.0) (resn DAN and name Y )
do (harmonic=0.0) (resn DAN and name Z )

igroup
  interaction (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end
  interaction (resn ANI or resn DAN or resn XAN)
              (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end
end

minimize powell nstep=40 drop=10 end
minimize powell nstep=40 drop=10 end

!define flexible segments:
@RUN:protocols/flex_segment_side.cns

do (mass =$Saprotocol.mass) (all)
do (mass=1000) (resn ANI or resn DAN or resn XAN)
do (fbeta = 0) (all)
do (fbeta = $Saprotocol.fbeta {1/ps} ) ( all )                

if ($failure eq false) then

if ($refine.solvshell eq true) then

  ! heat to 300 K
  for $bath in (100 200 300) loop heat
     do (harm = 0)  (all)
     do (harm = 5)  (not name h* and not resn ANI and not resn DAN and not resn XAN and not (resn WAT or resn HOH or resn TIP3))
     eval ($nchain1 = 0)
     while ($nchain1 < $data.ncomponents) loop nloop1
      eval ($nchain1=$nchain1+1)
      do (harm = 0)  (attribute store5 = $nchain1 and 
                      not ( name CA or name BB or name C or name N or name P or name C# or name C## ))
     end loop nloop1
     do (vx=maxwell($bath)) (all)
     do (vy=maxwell($bath)) (all)
     do (vz=maxwell($bath)) (all)  
     if ($Data.scaling eq true) then 
       inline @RUN:protocols/set_noe_scale.cns
     end if

     noe
       scale ambi $Data.amb_cool3 
       scale dist $Data.unamb_cool3
     end
     igroup
       interaction (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end
       interaction (resn ANI or resn DAN or resn XAN)
                   (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end
     end

     dynamics cartesian
        nstep=$refine.heatsteps timest=0.002{ps}       
        temperature=$bath  tcoupling = true
        nprint=50 
     end 
  end loop heat

  !define flexible segments:
  @RUN:protocols/flex_segment_back.cns

  do (harm = 0)  (all)
  do (harm = 1)  (not name h* and not resn ANI and not resn DAN and not resn XAN and not (resn WAT or resn HOH or resn TIP3))
  eval ($nchain1 = 0)
  while ($nchain1 < $data.ncomponents) loop nloop1
    eval ($nchain1=$nchain1+1)
    do (harm = 0)  (attribute store5 = $nchain1) 
  end loop nloop1
  do (harm = 20) (resn ANI and name OO)
  do (harm = 20) (resn DAN and name OO)

  if ($Data.scaling eq true) then 
    inline @RUN:protocols/set_noe_scale.cns
  end if

  noe
    scale ambi $Data.amb_cool3 
    scale dist $Data.unamb_cool3
  end
  igroup
    interaction (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end
    interaction (resn ANI or resn DAN or resn XAN)
                (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end
  end

  dynamics cartesian
     nstep=$refine.steps timest=0.002{ps}      
     temperature=$bath  tcoupling = true
     nprint=50 
  end 

  do (mass = $Saprotocol.mass) (all)
  do (harm = 0)  (all)
  do (harm = 1)  (name CA or name BB or name C or name N or name P or name C# or name C##)
  do (harm = 20) (resn ANI and name OO)
  do (harm = 20) (resn DAN and name OO)
  eval ($nchain1 = 0)
  while ($nchain1 < $data.ncomponents) loop nloop1
    eval ($nchain1=$nchain1+1)
    do (harm = 0)  (attribute store5 = $nchain1) 
  end loop nloop1

  ! cool 
  for $bath in (300 200 100) loop cool

     if ($Data.scaling eq true) then 
       inline @RUN:protocols/set_noe_scale.cns
     end if

     noe
       scale ambi $Data.amb_cool3 
       scale dist $Data.unamb_cool3
     end
     igroup
       interaction (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end
       interaction (resn ANI or resn DAN or resn XAN)
                   (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end
     end
     dynamics cartesian
        nstep=$refine.coolsteps timest=0.002{ps}      
        temperature=$bath  tcoupling = true                       
        nprint=50 
     end 
  end loop cool

end if

end if

if ($Data.scaling eq true) then 
  inline @RUN:protocols/set_noe_scale.cns
end if

noe
  scale ambi $Data.amb_cool3 
  scale dist $Data.unamb_cool3
end
igroup
  interaction (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end
  interaction (resn ANI or resn DAN or resn XAN)
              (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end
end

flag excl harm end

if ($Data.flags.cdih eq true) then
  flag incl cdih end
end if

mini powell nstep 200 end

{*== End if statement to turn on or off water refinement ==*}
end if 

{* ======================= calculate free molecules internal energy *}

parameter nbonds eps=1.0 end end

igroup
   interaction (not resn ANI and not resn DAN and not resn XAN and not (resn WAT or resn HOH or resn TIP*)) 
               (not resn ANI and not resn DAN and not resn XAN and not (resn WAT or resn HOH or resn TIP*)) weight * 1 end
end

fix sele=(resn ANI or resn DAN or resn XAN or resn WAT or resn HOH or resn TIP* or resn DMS or resn SHA) end

do (refx=x) (all)
do (refy=y) (all)
do (refz=z) (all)

flag excl noe dani sani vean xrdc xpcs coll cdih zhar end
flag include bond angle dihe impr vdw elec end

evaluate ($elec = 0.0)
evaluate ($eintfree = 0.0)
inline @RUN:protocols/calc_free-ene.cns

fix sele=(not all) end

! fix the shape
fix sele = (resn SHA) end

do (x = refx) (all)
do (y = refy) (all)
do (z = refz) (all)

{* ======================= final analysis *}

igroup
   interaction (not resn ANI and not resn DAN and not resn XAN and not (resn WAT or resn HOH or resn TIP*)) 
               (not resn ANI and not resn DAN and not resn XAN and not (resn WAT or resn HOH or resn TIP*)) weight * 1 end
end

evaluate ($esolcplx = 0.0)
evaluate ($edesolv = 0.0)

{* ===================== calculate complex internal energy *}
evaluate ($kinter = 1.0)
@RUN:protocols/scale_intra_only.cns
energy end
evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec)
if ($data.ncomponents = 1) then
  evaluate ($eintfree = $eintcplx)
end if

{* ===================== calculate final energies and write structure *}
if ($data.ncomponents > 1) then
  evaluate ($kinter = 1.0)
  @RUN:protocols/scale_inter_final.cns
else
  @RUN:protocols/scale_intra_only.cns
end if

evaluate ($cdih=0.0)
flag incl noe cdih end
if ($Data.flags.sani eq true) then
  flag incl sani end
end if
if ($Data.flags.xrdc eq true) then
  flag incl xrdc end
end if
if ($Data.flags.xpcs eq true) then
  flag incl xpcs end
end if
if ($Data.flags.dani eq true) then
  flag incl dani end
end if
if ($Data.flags.vean eq true) then
   flag incl vean end
end if

noe 
  scale dist $Data.unamb_cool3 
  scale ambi $Data.amb_cool3
  scale hbon 0.0
  scale symm 0.0
  scale cont 0.0
end
energy end
evaluate ($eair= $noe)
evaluate ($rms_test_noe=0.0)
evaluate ($violations_test_noe=0)
evaluate ($esym = 0.0)
evaluate ($ncs = 0.0)
evaluate ($zhar = 0.0)
if ($Data.flags.sym  eq true) then
  noe reset nres= 2000000 end
  @RUN:protocols/symmultimer.cns
  noe
    scale symm $Data.ksym
  end
  energy end
  evaluate ($esym = $noe)
  if ($Data.noecv eq true) then
    evaluate ($violations_test_noe=0)
    evaluate ($rms_test_noe=0.0)
    display Print out of cross-validated violations and rms not
    display possible in combination with symmetry restraints
    display CV values set therefore to 0
  end if
  noe reset nres= 2000000 end
  set message=normal echo=on end
  !read all the experimental Data:
!  @@RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count)
  @@RUN:protocols/read_noes.cns
  if ( $log_level = "verbose" ) then
    set message=normal echo=on end
  else
    set message=off echo=off end
  end if
else
  print threshold=0.3 noe
  evaluate ($rms_noe=$result)
  evaluate ($violations_noe=$violations)
  if ($Data.noecv eq true) then
    evaluate ($rms_test_noe=$test_rms)
    evaluate ($violations_test_noe=$test_violations)
  else
    evaluate ($rms_test_noe=0.0)
    evaluate ($violations_test_noe=0)
  end if
end if

if ($Data.dnarest eq true) then
  @@$dna_rest_file
!  @RUN:data/sequence/dna-rna_restraints.def
end if

energy end
evaluate ($etot = $ener - $noe)
evaluate ($noe = $eair)
evaluate ($etot = $etot + $noe)
if ($data.flags.em = true) then
!    @RUN:protocols/em_calc_lcc.cns(toppar=$toppar; data=$data;
!            saprotocol=$saprotocol; lcc=$lcc;)
    @RUN:protocols/em_calc_lcc.cns
    flags exclude xref end
end if

if ($refine.keepwater eq true) then
  evaluate ($filename= "NEWIT:water/" + $file - "PREVIT:" - ".pdb" + "_h2o-all.pdb")
  write coordinates sele= (all) output =$filename end
end if

evaluate ($Data.flags.dihed = false) 
evaluate ($filename= "NEWIT:water/" + $file - "PREVIT:" - ".pdb" + "w.pdb0")
@RUN:protocols/print_coorheader.cns

do (q=1) (all)
!write coordinates sele= (not (resn WAT or resn HOH or resn TIP*)) output =$filename end
write coordinates sele= (not (resn WAT or resn HOH or resn TIP*)) output =$output_pdb_filename end

if ($refine.keepwater eq true) then
  evaluate ($filename= "NEWIT:water/" + $file - "PREVIT:" - ".pdb" + "_h2o-inter.pdb")
!  write coordinates sele= (all) output =$filename end
  write coordinates sele= (all) output =$output_pdb_filename end
end if

 set message=normal echo=on end
 display OUTPUT: $output_pdb_filename

stop

