! protein-ss-restraints-all.def
!    Define automatically secondary stucture dihedral angle restraints for all residues
!
! ***********************************************************************
! * Copyright 2003-2022 Alexandre Bonvin, Utrecht University.           *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!
{+ file: protein-ss-restraints.def +}
{+ description: Creates dihedral angle restraints to maintain conformation of the protein backbone +}
{+ authors: Axel T. Brunger, and Paul D. Adams, +}
{+ modified by Alexandre Bonvin for HADDOCK use +}

{=========================================================================================================}
{                        things below this line do not normally need to be changed                        }
{=========================================================================================================}

{- Dihedral restraints for the protein backbone -}
restraint dihedral
    nass = 10000
end
do (store1 = 1) (all)
evaluate ($group=1)
evaluate ($done=false)
while ( $done = false ) loop bdihe
    if ( $exist_Toppar.prot_segid_$group = true ) then
        show sum(1) ( segid $Toppar.prot_segid_$group )
        if ( $result > 0 ) then
            evaluate ($error_phi=$Data.error_dih)
            evaluate ($error_psi=$Data.error_dih)
            for $id in id ( segid $Toppar.prot_segid_$group and tag and not resn TIP3 ) loop resid
                show (segid) (id $id)
                evaluate ($segid=$result)
                show (resid) ( id $id )
                evaluate ($resid=decode($result))
                evaluate ($rprec = $resid - 1)
                show sum (store1) (resid $rprec and name C)
                if ($result ne 0) then
                    evaluate ($rprec = $resid - 1)
                    pick dihedral
                        ( segid $segid and resid $rprec and name C )
                        ( segid $segid and resid $resid and name N )
                        ( segid $segid and resid $resid and name CA )
                        ( segid $segid and resid $resid and name C ) 
                    geometry
                    evaluatate ($dihedral_phi=$result)
                    restraint dihedral
                        ! phi
                        assign  ( segid $segid and resid $rprec and name C )
                                ( segid $segid and resid $resid and name N )
                                ( segid $segid and resid $resid and name CA )
                                ( segid $segid and resid $resid and name C ) 
                                1.0 $dihedral_phi $error_phi 2
                        scale 200.0
                    end
                end if
                evaluate ($rnext = $resid + 1)
                show sum (store1) (resid $rnext and name N)
                if ($result ne 0) then
                    pick dihedral
                        ( segid $segid and resid $resid and name N )
                        ( segid $segid and resid $resid and name CA )
                        ( segid $segid and resid $resid and name C )
                        ( segid $segid and resid $rnext and name N ) 
                    geometry
                    evaluatate ($dihedral_psi=$result)
                    restraint dihedral
                        ! psi
                        assign  ( segid $segid and resid $resid and name N )
                                ( segid $segid and resid $resid and name CA )
                                ( segid $segid and resid $resid and name C )
                                ( segid $segid and resid $rnext and name N ) 
                                1.0 $dihedral_psi $error_psi 2
                        scale 200.0
                    end
                end if
            end loop resid
        end if
    else
        evaluate ($done=true)
    end if
    evaluate ($group=$group+1)
end loop bdihe

flags include cdih end
