! rigidbody.cns
!    The basic rigid-body docking CNS script for HADDOCK3 with support only
!    for distance-based restraints and symmetry restrainted
!
! ***********************************************************************
! * Copyright 2003-2022 Alexandre Bonvin, Utrecht University.           *
! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************

eval ($iteration = 0)

!==================================================================!
! Initialisation of variables
!==================================================================!

evaluate ($saprotocol.crossdock=$crossdock)
evaluate ($saprotocol.randorien=$randorien)
evaluate ($saprotocol.rigidmini=$rigidmini)
evaluate ($saprotocol.rigidtrans=$rigidtrans)
evaluate ($saprotocol.ntrials=$ntrials)
evaluate ($saprotocol.iniseed=$iniseed)
evaluate ($saprotocol.inter_rigid=$inter_rigid)
evaluate ($saprotocol.rotate180_it0=$rotate180_it0)
evaluate ($fileroot="")
evaluate ($filenames.fileroot=$fileroot)

evaluate ($iterations.ini_count    =1)
evaluate ($iterations.structures   =$sampling)
evaluate ($iterations.w_vdw        =$w_vdw_$iteration)
evaluate ($iterations.w_elec       =$w_elec_$iteration)
evaluate ($iterations.w_dist       =$w_dist_$iteration)
evaluate ($iterations.w_rg         =$w_rg_$iteration)
evaluate ($iterations.w_sani       =$w_sani_$iteration)
evaluate ($iterations.w_xrdc       =$w_xrdc_$iteration)
evaluate ($iterations.w_xpcs       =$w_xpcs_$iteration)
evaluate ($iterations.w_dani       =$w_dani_$iteration)
evaluate ($iterations.w_vean       =$w_vean_$iteration)
evaluate ($iterations.w_cdih       =$w_cdih_$iteration)
evaluate ($iterations.w_sym        =$w_sym_$iteration)
evaluate ($iterations.w_zres       =$w_zres_$iteration)
evaluate ($iterations.w_bsa        =$w_bsa_$iteration)
evaluate ($iterations.w_deint      =$w_deint_$iteration)
evaluate ($iterations.w_desolv     =$w_desolv_$iteration)
evaluate ($iterations.anastruc     =$anastruc_$iteration)
evaluate ($iterations.w_lcc        =$w_lcc_$iteration)


evaluate ($data.ncomponents=$ncomponents)

evaluate ($nmol=1)
while ($nmol <= $data.ncomponents) loop mol
  evaluate ($toppar.fix_origin_$nmol=$fix_origin_mol$nmol)
  evaluate ($toppar.dna_$nmol=$dna_mol$nmol)
  evaluate ($toppar.cyclicpept_$nmol = $cyclicpept_mol$nmol)
  evaluate ($toppar.shape_$nmol = $shape_mol$nmol)
  evaluate ($toppar.cg_$nmol = $cg_mol$nmol)
  evaluate ($toppar.prot_segid_$nmol = $prot_segid_$nmol)
  evaluate ($nmol = $nmol + 1)
end loop mol

! non-bonded parameter set to use
evaluate ($toppar.par_nonbonded = $par_nonbonded)

! Symmetry restraints
evaluate ($data.ksym = $ksym)
evaluate ($Data.flags.sym = $sym_on)
evaluate ($data.numc2sym = $numc2sym)
evaluate ($nsym=1)
while ($nsym <= $numc2sym) loop sym
    evaluate ($toppar.c2sym_sta1_$nsym = $c2sym_sta1_$nsym)
    evaluate ($toppar.c2sym_end1_$nsym = $c2sym_end1_$nsym)
    evaluate ($toppar.c2sym_seg1_$nsym = $c2sym_seg1_$nsym)
    evaluate ($toppar.c2sym_sta2_$nsym = $c2sym_sta2_$nsym)
    evaluate ($toppar.c2sym_end2_$nsym = $c2sym_end2_$nsym)
    evaluate ($toppar.c2sym_seg2_$nsym = $c2sym_seg2_$nsym)
    evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc3sym = $numc3sym)
evaluate ($nsym=1)
while ($nsym <= $numc3sym) loop sym
    evaluate ($toppar.c3sym_sta1_$nsym = $c3sym_sta1_$nsym)
    evaluate ($toppar.c3sym_end1_$nsym = $c3sym_end1_$nsym)
    evaluate ($toppar.c3sym_seg1_$nsym = $c3sym_seg1_$nsym)
    evaluate ($toppar.c3sym_sta2_$nsym = $c3sym_sta2_$nsym)
    evaluate ($toppar.c3sym_end2_$nsym = $c3sym_end2_$nsym)
    evaluate ($toppar.c3sym_seg2_$nsym = $c3sym_seg2_$nsym)
    evaluate ($toppar.c3sym_sta3_$nsym = $c3sym_sta3_$nsym)
    evaluate ($toppar.c3sym_end3_$nsym = $c3sym_end3_$nsym)
    evaluate ($toppar.c3sym_seg3_$nsym = $c3sym_seg3_$nsym)
    evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.nums3sym= $nums3sym)
evaluate ($nsym=1)
while ($nsym <= $nums3sym) loop sym
     evaluate ($toppar.s3sym_sta1_$nsym = $s3sym_sta1_$nsym)
     evaluate ($toppar.s3sym_end1_$nsym = $s3sym_end1_$nsym)
     evaluate ($toppar.s3sym_seg1_$nsym = $s3sym_seg1_$nsym)
     evaluate ($toppar.s3sym_sta2_$nsym = $s3sym_sta2_$nsym)
     evaluate ($toppar.s3sym_end2_$nsym = $s3sym_end2_$nsym)
     evaluate ($toppar.s3sym_seg2_$nsym = $s3sym_seg2_$nsym)
     evaluate ($toppar.s3sym_sta3_$nsym = $s3sym_sta3_$nsym)
     evaluate ($toppar.s3sym_end3_$nsym = $s3sym_end3_$nsym)
     evaluate ($toppar.s3sym_seg3_$nsym = $s3sym_seg3_$nsym)
     evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc4sym = $numc4sym)
evaluate ($nsym=1)
while ($nsym <= $numc4sym) loop sym
     evaluate ($toppar.c4sym_sta1_$nsym = $c4sym_sta1_$nsym)
     evaluate ($toppar.c4sym_end1_$nsym = $c4sym_end1_$nsym)
     evaluate ($toppar.c4sym_seg1_$nsym = $c4sym_seg1_$nsym)
     evaluate ($toppar.c4sym_sta2_$nsym = $c4sym_sta2_$nsym)
     evaluate ($toppar.c4sym_end2_$nsym = $c4sym_end2_$nsym)
     evaluate ($toppar.c4sym_seg2_$nsym = $c4sym_seg2_$nsym)
     evaluate ($toppar.c4sym_sta3_$nsym = $c4sym_sta3_$nsym)
     evaluate ($toppar.c4sym_end3_$nsym = $c4sym_end3_$nsym)
     evaluate ($toppar.c4sym_seg3_$nsym = $c4sym_seg3_$nsym)
     evaluate ($toppar.c4sym_sta4_$nsym = $c4sym_sta4_$nsym)
     evaluate ($toppar.c4sym_end4_$nsym = $c4sym_end4_$nsym)
     evaluate ($toppar.c4sym_seg4_$nsym = $c4sym_seg4_$nsym)
     evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc5sym=$numc5sym)
evaluate ($nsym=1)
while ($nsym <= $numc5sym) loop sym
    evaluate ($toppar.c5sym_sta1_$nsym = $c5sym_sta1_$nsym)
    evaluate ($toppar.c5sym_end1_$nsym = $c5sym_end1_$nsym)
    evaluate ($toppar.c5sym_seg1_$nsym = $c5sym_seg1_$nsym)
    evaluate ($toppar.c5sym_sta2_$nsym = $c5sym_sta2_$nsym)
    evaluate ($toppar.c5sym_end2_$nsym = $c5sym_end2_$nsym)
    evaluate ($toppar.c5sym_seg2_$nsym = $c5sym_seg2_$nsym)
    evaluate ($toppar.c5sym_sta3_$nsym = $c5sym_sta3_$nsym)
    evaluate ($toppar.c5sym_end3_$nsym = $c5sym_end3_$nsym)
    evaluate ($toppar.c5sym_seg3_$nsym = $c5sym_seg3_$nsym)
    evaluate ($toppar.c5sym_sta4_$nsym = $c5sym_sta4_$nsym)
    evaluate ($toppar.c5sym_end4_$nsym = $c5sym_end4_$nsym)
    evaluate ($toppar.c5sym_seg4_$nsym = $c5sym_seg4_$nsym)
    evaluate ($toppar.c5sym_sta5_$nsym = $c5sym_sta5_$nsym)
    evaluate ($toppar.c5sym_end5_$nsym = $c5sym_end5_$nsym)
    evaluate ($toppar.c5sym_seg5_$nsym = $c5sym_seg5_$nsym)
    evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc6sym=$numc6sym)
evaluate ($nsym=1)
while ($nsym <= $numc6sym) loop sym
    evaluate ($toppar.c6sym_sta1_$nsym = $c6sym_sta1_$nsym)
    evaluate ($toppar.c6sym_end1_$nsym = $c6sym_end1_$nsym)
    evaluate ($toppar.c6sym_seg1_$nsym = $c6sym_seg1_$nsym)
    evaluate ($toppar.c6sym_sta2_$nsym = $c6sym_sta2_$nsym)
    evaluate ($toppar.c6sym_end2_$nsym = $c6sym_end2_$nsym)
    evaluate ($toppar.c6sym_seg2_$nsym = $c6sym_seg2_$nsym)
    evaluate ($toppar.c6sym_sta3_$nsym = $c6sym_sta3_$nsym)
    evaluate ($toppar.c6sym_end3_$nsym = $c6sym_end3_$nsym)
    evaluate ($toppar.c6sym_seg3_$nsym = $c6sym_seg3_$nsym)
    evaluate ($toppar.c6sym_sta4_$nsym = $c6sym_sta4_$nsym)
    evaluate ($toppar.c6sym_end4_$nsym = $c6sym_end4_$nsym)
    evaluate ($toppar.c6sym_seg4_$nsym = $c6sym_seg4_$nsym)
    evaluate ($toppar.c6sym_sta5_$nsym = $c6sym_sta5_$nsym)
    evaluate ($toppar.c6sym_end5_$nsym = $c6sym_end5_$nsym)
    evaluate ($toppar.c6sym_seg5_$nsym = $c6sym_seg5_$nsym)
    evaluate ($toppar.c6sym_sta6_$nsym = $c6sym_sta6_$nsym)
    evaluate ($toppar.c6sym_end6_$nsym = $c6sym_end6_$nsym)
    evaluate ($toppar.c6sym_seg6_$nsym = $c6sym_seg6_$nsym)
    evaluate ($nsym = $nsym + 1)
end loop sym

if ( $data.numc2sym eq 6) then
    evaluate ($saprotocol.rotate180_it0 = false)
end if
if ( $data.numc3sym ne 0) then
    evaluate ($saprotocol.rotate180_it0 = false)
end if
if ( $data.numc4sym ne 0) then
    evaluate ($saprotocol.rotate180_it0 = false)
end if
if ( $data.numc5sym ne 0) then
    evaluate ($saprotocol.rotate180_it0 = false)
end if
if ( $data.numc6sym ne 0) then
    evaluate ($saprotocol.rotate180_it0 = false)
end if

! distance restraints
evaluate ($Data.flags.noe  =  true)
evaluate ($data.scaling=$air_scaling)
evaluate ($data.totnoe_unamb=$tot_unamb)
evaluate ($data.unamb_firstit=$unamb_firstit)
evaluate ($data.unamb_lastit=$unamb_lastit)
evaluate ($data.unamb_hot=$unamb_hot)
evaluate ($data.unamb_cool1=$unamb_cool1)
evaluate ($data.unamb_cool2=$unamb_cool2)
evaluate ($data.unamb_cool3=$unamb_cool3)
evaluate ($data.noecv=$noecv)
evaluate ($data.ncvpart=$ncvpart)

evaluate ($data.totnoe_amb=$tot_amb)
evaluate ($data.amb_firstit=$amb_firstit)
evaluate ($data.amb_lastit=$amb_lastit)
evaluate ($data.amb_hot=$amb_hot)
evaluate ($data.amb_cool1=$amb_cool1)
evaluate ($data.amb_cool2=$amb_cool2)
evaluate ($data.amb_cool3=$amb_cool3)

evaluate ($data.hbond_firstit=$hbond_firstit)
evaluate ($data.hbond_lastit=$hbond_lastit)
evaluate ($data.hbond_hot=$hbond_hot)
evaluate ($data.hbond_cool1=$hbond_cool1)
evaluate ($data.hbond_cool2=$hbond_cool2)
evaluate ($data.hbond_cool3=$hbond_cool3)

evaluate ($data.mrswi_hot=$mrswi_hot)
evaluate ($data.mrswi_cool1=$mrswi_cool1)
evaluate ($data.mrswi_cool2=$mrswi_cool2)
evaluate ($data.mrswi_cool3=$mrswi_cool3)

evaluate ($data.rswi_hot=$rswi_hot)
evaluate ($data.rswi_cool1=$rswi_cool1)
evaluate ($data.rswi_cool2=$rswi_cool2)
evaluate ($data.rswi_cool3=$rswi_cool3)

evaluate ($data.masy_hot=$masy_hot)
evaluate ($data.masy_cool1=$masy_cool1)
evaluate ($data.masy_cool2=$masy_cool2)
evaluate ($data.masy_cool3=$masy_cool3)

evaluate ($data.asy_hot=$asy_hot)
evaluate ($data.asy_cool1=$asy_cool1)
evaluate ($data.asy_cool2=$asy_cool2)
evaluate ($data.asy_cool3=$asy_cool3)

evaluate ($data.ranair=$ranair)
if ($data.ranair eq true) then
    evaluate ($data.noecv = false)
end if
evaluate ($data.cmrest=$cmrest)
evaluate ($data.cmtight=$cmtight)
evaluate ($data.kcont=$kcont)
evaluate ($data.surfrest=$surfrest)
evaluate ($data.ksurf=$ksurf)

! keep or delete non-polar hydrogens
evaluate ($toppar.delenph=$delenph)


!Electrostatics:
evaluate ($Data.flags.dihed =$dihedflag)
evaluate ($Data.flags.elec0 =$elecflag_0)
evaluate ($Data.flags.elec1 =$elecflag_1)
evaluate ($Data.epsilon0 =$epsilon_0)
evaluate ($Data.epsilon1 =$epsilon_1)
evaluate ($Data.dielec0  =$dielec_0)
evaluate ($Data.dielec1  =$dielec_1)


!Interaction matrix:
evaluate ($nmol1=1)
while ($nmol1 <=$data.ncomponents) loop mol1
    evaluate ($nmol2=$nmol1 + 1)
    evaluate ($toppar.int_$nmol1_$nmol1 =int_$nmol1_$nmol1)
    while ($nmol2 <=$data.ncomponents) loop mol2
        evaluate ($toppar.int_$nmol1_$nmol2 =$int_$nmol1_$nmol2)
        evaluate ($toppar.int_$nmol2_$nmol1 =$int_$nmol1_$nmol2)
        evaluate ($nmol2=$nmol2 + 1)
    end loop mol2
    evaluate ($nmol1 = $nmol1 + 1)
end loop mol1


!for the non-bonded parameters (the section was taken out of
!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!):
if ($toppar.par_nonbonded eq "PROLSQ") then
    evaluate ($toppar.repel_radius = 1.0)
    evaluate ($toppar.repel_rcons = 20)
    evaluate ($toppar.repel_rexpo  = 4)
    evaluate ($toppar.repel_irexp  = 1)
elseif ($toppar.par_nonbonded eq "PARMALLH6") then
    evaluate ($toppar.repel_radius = 0.8)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
elseif ($toppar.par_nonbonded eq "OPLSX") then
    evaluate ($toppar.repel_radius = 0.0)
else        {...now the standard PARALLHDG parameters}
    evaluate ($toppar.repel_radius = 0.78)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
end if

! Restraints
evaluate ($npart = $ncvpart)

! Unsupported restraints
evaluate ($Data.flags.cdih = false)
evaluate ($Data.flags.em   = false)
evaluate ($Data.flags.rg   = false)
evaluate ($Data.flags.zres = false)
evaluate ($Data.flags.sani = false)
evaluate ($Data.flags.xrdc = false)
evaluate ($Data.flags.xpcs = false)
evaluate ($Data.flags.dani = false)
evaluate ($Data.flags.vean = false)

!==================================================================!


parameter
    nbonds
        nbxmod=5 atom cdie shift
        cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=1.0 e14fac=0.4 inhibit 0.25
        wmin=0.5 tolerance  0.5
    end
end

igroup
    interaction  (not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA))
                 (not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1 end
    interaction  (resn ANI or resn DAN or resn XAN or resn DUM or resn DUM)
                 (resn ANI or resn DAN or resn XAN or resn DUM or resn DUM) weight * 1 vdw 0.0 elec 0.0 end
    interaction  (resn SHA) (not resn SHA) weight * 0 end
end

flag include bond angle impr vdw end

evaluate ($end_count = $iterations.ini_count + $iterations.structures - 1)

if ($Data.noecv eq true) then
    evaluate ($npart = 1 + mod($count,$Data.ncvpart))
    evaluate ($fileseed=$output_pdb_filename - ".pdb" + ".seed")
    evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
    set display=$fileseed end
    display module(seed;npart)
    display define (
    display currentseed = $seed;
    display currentpart = $npart;
    display )
    display evaluate (&seed=&currentseed)
    display evaluate (&npart=&currentpart)
    close $fileseed end
else
    evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
end if
set seed $seed end


{* Find CoM of protein *}
show ave (x) (name CA or name BB or name C1')
evaluate ($xcent=$result)
show ave (y) (name CA or name BB or name C1')
evaluate ($ycent=$result)
show ave (z) (name CA or name BB or name C1')
evaluate ($zcent=$result)


do (refx=x) (all)
do (refy=y) (all)
do (refz=z) (all)

!read all the experimental Data:
evaluate ($lcc = 0)
set seed $seed end
set message=normal echo=on end
!inline @RUN:read_data.cns
inline @RUN:read_noes.cns  ! rigidbody version with only distance restraints support

{* ======================= reset coordinates and proceed *}

do (x = refx) (all)
do (y = refy) (all)
do (z = refz) (all)

!set the energy flags:
if ($Data.flags.noe  =  TRUE) then
     flags include noe end
end if

{* random removal of restaints ================================== *}
if ($Data.noecv eq true) then
    set message=on echo=on end
    noe cv $npart ? end
else
    evaluate ($npart = 0)
end if

if ( $log_level = verbose ) then
     set message=normal echo=on end
else
     set message=off echo=off end
end if


{* ============================================================== *}

! determine whether the final models should be reoriented along their principal
! axes before writing to file in it0 and it1
eval($reorient = true)
! check for fixed molecules
eval($fixmol = false)
evaluate ($ncount = 0)
while ($ncount < $data.ncomponents) loop orientmol
    evaluate ($ncount = $ncount + 1)
    eval($watersegname_$ncount="WA" + encode($ncount))
    if ($Toppar.fix_origin_$ncount eq true) then
        eval($reorient = false)
        eval($fixmol = true)
    end if
end loop orientmol


eval ($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop1
    eval($nchain1 = $nchain1 + 1)
    if ($Toppar.fix_origin_$nchain1 eq true) then
        eval($reorient = false)
    end if
end loop nloop1

evaluate ($numnoe = 0)

{*======================= random orientations and rigid body minimisation *}
if ($SaProtocol.rigidmini eq true) then
    !Make sure that at least as many distance restraints are successfully
    !read as the number of partitions for cross-validation
    evaluate ($numnoe = 0)
    noe ? end
    if ($NUMNOE = 0) then
      if ($Data.ncomponents > 1) then
        if ($Data.surfrest eq FALSE) then
          if ($Data.cmrest eq FALSE) then
            if ($Data.ranair eq FALSE) then
                evaluate ($errfile = "WARNING")
                fileexist $errfile end
                if ($result eq false) then
                  set display=$errfile end
                  display TOTAL NUMBER OF DISTANCE RESTRAINTS FOR RIGID BODY DOCKING IS ZERO!
                  display CONTROL YOUR PARAMETER SETTINGS AND RESTRAINT DEFINITIONS
                  display STRUCTURE NUMBER $count
                  close $errfile end
                end if
            end if
          end if
        end if
      end if
      evaluate ($Data.ncvpart = 1)
      evaluate ($Data.noecv = FALSE)
    end if
end if

if ($NUMNOE lt $Data.ncvpart) then
    noe part=1 end
    evaluate ($Data.ncvpart = 1)
    evaluate ($Data.noecv = FALSE)
end if

flag excl bond angl dihe impr zhar end

if ($Data.flags.elec0 eq true) then
    flag include elec end
    if ($Data.dielec0 eq rdie) then
        parameter nbonds eps=$Data.epsilon0 rdie shift switch end end
        ! shift statement needed first to activate switch (CNS bug?)
    else
        parameter nbonds eps=$Data.epsilon0 cdie shift end end
    end if
    parameter nbonds ? end end
else
    evaluate ($elec=0.0)
    flag exclude elec end
end if

flag excl cdih end

if ($Data.ranair eq true) then
    if ($Data.ncomponents > 2) then
        evaluate ($errfile = "FAILED")
        fileexist $errfile end
        if ($result eq false) then
            set display=$errfile end
            display ========= Unsupported option ===========
            display Random definition of AIRs with more than
            display two molecules currently unsupported
            display ========================================
            close $errfile end
        end if
        stop
    end if
    evaluate ($Data.noecv = false)
    noe
        reset
        nrestraints = 100000     ! allocate space for NOEs
        ceiling 1000
    end
    @RUN:randomairs.cns

    !Read back in hbond data
    if (&data.hbond_lastit ge &iteration) then
        if (&data.hbond_firstit le &iteration) then
            if (&data.hbonds_on eq true) then
                noe @@RUN:data/hbonds/hbonds.tbl end
            end if
        end if
    end if

    noe
        averaging  * sum
        potential  * soft
        scale      * 1.0
        sqconstant * 1.0
        sqexponent * 2
        soexponent * 1
        rswitch    * 1.0
        sqoffset   * 0.0
        asymptote  * 2.0
        msoexponent * 1
        masymptote  * -0.1
        mrswitch    * 1.0
        avexpo hbond 20
    end
end if

@RUN:symmultimer.cns

if ($Data.cmrest eq true ) then
    @RUN:cm-restraints.cns
end if

if ($Data.surfrest eq true ) then
    @RUN:surf-restraints.cns
end if

flag excl ncs end
evaluate ($nrig = 0)
evaluate ($nfirst = 1)
evaluate ($bestair = 0)

while ($nrig < $SaProtocol.ntrials) loop trials

    evaluate ($nrig = $nrig + 1)

    if ( $log_level = verbose ) then
        set message=normal echo=on end
    else
        set message=off echo=off end
    end if

    ! random placement of molecules
    if ($SaProtocol.randorien eq true) then
        @RUN:separate.cns
        @RUN:random_rotations.cns
    end if

    evaluate ($unamb_scale = 1.0)
    evaluate ($ambig_scale = 1.0)
    evaluate ($hbond_scale = 1.0)
    evaluate ($symm_scale = 1.0)
    evaluate ($cont_scale = 0.0)
    evaluate ($surf_scale = 0.0)

    noe
        scale dist $unamb_scale
        scale ambi $ambig_scale
        scale hbon $hbond_scale
        scale symm $symm_scale
        scale contact $cont_scale
        scale surface $surf_scale
    end

    evaluate ($kinter = $SaProtocol.inter_rigid)
    @RUN:scale_inter_mini.cns

    ! a few rounds of rotational rigid body minimization for each independent chain
    evaluate ($imini = 0)
    while ($imini le 4) loop rigmin

        evaluate ($imini = $imini + 1)
        eval ($ministeps = 500 * nint ($data.ncomponents/6 + 1))
        if ($SaProtocol.randorien eq true) then
            flag excl vdw elec end
        end if
        eval ($nchain1 = 0)
        while ($nchain1 < $data.ncomponents) loop nloop1
            eval($nchain1 = $nchain1 + 1)
            if ($Toppar.fix_origin_$nchain1 eq false) then
                fix sele=(not all) end
                fix sele=( not (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name OO) end
                minimize rigid
                    group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP)
                    translation=false
                    nstep $ministeps
                    drop 10.0
                    tole 0.1
                    nprint 10
                end
            end if
        end loop nloop1
        fix sele=(not all) end

        flag include vdw end
        if ($Data.flags.elec0 eq true) then
            flag include elec end
        end if

        evaluate ($unamb_scale = min(($unamb_scale * 2),$Data.unamb_cool3))
        evaluate ($ambig_scale = min(($ambig_scale * 2),$Data.amb_cool3))
        evaluate ($hbond_scale = min(($hbond_scale * 2),$Data.hbond_cool3))
        evaluate ($symm_scale = min(($symm_scale * 2),$Data.ksym))

        noe
            scale dist $unamb_scale
            scale ambi $ambig_scale
            scale hbon $hbond_scale
            scale symm $symm_scale
        end

    end loop rigmin

    evaluate ($unamb_scale_store = $unamb_scale)
    evaluate ($ambig_scale_store = $ambig_scale)
    evaluate ($hbond_scale_store = $hbond_scale)
    evaluate ($symm_scale_store = $symm_scale)

    flag include vdw end
    if ($Data.flags.elec0 eq true) then
        flag include elec end
    end if

    if ($SaProtocol.rigidtrans eq true) then

        evaluate ($cont_scale = $Data.kcont)
        evaluate ($surf_scale = $Data.ksurf)
        noe
            scale contact $cont_scale
            scale surface $surf_scale
        end
        fix sele=(name OO and not resn XAN) end
        minimize rigid
            eval ($nchain1 = 0)
            while ($nchain1 < $data.ncomponents) loop nloop1
                eval($nchain1 = $nchain1 + 1)
                if ($Toppar.fix_origin_$nchain1 eq false) then
                    group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP)
                end if
                translation=false
            end loop nloop1
            nstep 1000
            nprint 10
        end

        energy end

        fix sele=(name OO and not resn XAN) end
        minimize rigid
            eval ($nchain1 = 0)
            while ($nchain1 < $data.ncomponents) loop nloop1
                eval($nchain1 = $nchain1 + 1)
                if ($Toppar.fix_origin_$nchain1 eq false) then
                    group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP)
                end if
                translation=true
            end loop nloop1
            nstep $ministeps
            nprint 10
        end

        energy end

        fix sele=(name OO and not resn XAN) end
        minimize rigid
            eval ($nchain1 = 0)
            while ($nchain1 < $data.ncomponents) loop nloop1
                eval($nchain1 = $nchain1 + 1)
                if ($Toppar.fix_origin_$nchain1 eq false) then
                    group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP* or name MAP))
                end if
                translation=true
            end loop nloop1
            for $id in id (segid WA* and (resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater
                group (byres(id $id))
            end loop miniwater
            translation=true
            nstep $ministeps
            nprint 10
        end
        energy end

        fix sele=(not all) end

    end if ! ($Saprotocol.rigidtrans eq true)

    inline @RUN:bestener.cns

    if ($saprotocol.rotate180_it0 eq true) then
        eval($nchain1 = 0)
        while ($nchain1 < $data.ncomponents) loop nloop4
            eval($nchain1 = $nchain1 + 1)
            if ($Toppar.shape_$nchain1 eq false) then
                eval($nchain2 = $nchain1 )
                while ($nchain2 < $data.ncomponents) loop nloop3
                    eval($nchain2 = $nchain2 + 1)
                    if ($Toppar.shape_$nchain2 eq false) then
                        @RUN:rotation180.cns
                        inline @RUN:bestener.cns
                    end if
                end loop nloop3
            end if
        end loop nloop4
    end if

end loop trials


{* ===================== calculate complex internal energy *}
evaluate ($kinter = 1.0)
@RUN:scale_intra_only.cns

flag include bond angle dihe impr vdw end

evaluate ($elec = 0.0)
evaluate ($eintfree = 0.0)
if ($Data.flags.elec0 eq true) then
    flag include elec end
end if

energy end

evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec)
evaluate ($eintfree = $eintcplx) 
{* at this stage the two are similar since rigid-body EM only *}

{* =========================== write out structure after rigid body refinement *}

!bestener.cns: for waterdock, store3 contains store5 from lowest energy structure
do (x = refx) (not store3)
do (y = refy) (not store3)
do (z = refz) (not store3)

evaluate ($esym = 0.0)
evaluate ($ncs = 0.0)
evaluate ($zhar = 0.0)
evaluate ($rms_test_noe = 0.0)
evaluate ($violations_test_noe = 0)
if ($Data.flags.sym eq true) then
    noe reset nres= 2000000 end
    @RUN:symmultimer.cns
    noe
        scale symm $Data.ksym
    end
    energy end
    evaluate ($esym = $noe)
    if ($Data.noecv eq true) then
        display Print out of cross-validated violations and rms not
        display possible in combination with symmetry restraints
        display CV values set therefore to 0
    end if
    noe reset end
    set message=normal echo=on end
    !read again the NOE data, needed to remove the symmetry restraints
    @@RUN:read_noes.cns
    if ( $log_level = verbose ) then
        set message=normal echo=on end
    else
        set message=off echo=off end
    end if
else
    if ($Data.noecv eq true) then
        set message=on echo=on end
        noe cv $ncvbest ? end
    end if
    if ( $log_level = verbose ) then
        set message=normal echo=on end
    else
        set message=off echo=off end
    end if
    print threshold=0.3 noe
    evaluate ($rms_noe=$result)
    evaluate ($violations_noe=$violations)
    if ($Data.noecv eq true) then
        evaluate ($rms_test_noe=$test_rms)
        evaluate ($violations_test_noe=$test_violations)
    end if
end if

evaluate ($unamb_scale = $Data.unamb_cool3)
evaluate ($ambig_scale = $Data.amb_cool3)
evaluate ($hbond_scale = $Data.hbond_cool3)

noe
    scale dist $unamb_scale
    scale ambi $ambig_scale
    scale hbon 0.0
    scale cont 0.0
end

{* ===================== calculate final energies and write structure *}
flag incl bond angl impr noe end

if ($data.ncomponents > 1) then
    evaluate ($kinter = 1.0)
    @RUN:scale_inter_final.cns
else
    @RUN:scale_intra_only.cns
end if

energy end
evaluate ($cdih = 0.0)
evaluate ($etot = $ener - $noe)
evaluate ($noe = $bestair)
evaluate ($etot = $etot + $noe)

evaluate ($Data.flags.dihed = false)
evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".pdb0")
inline @RUN:print_coorheader.cns

if ($reorient eq true) then
    coor sele=(segid $Toppar.prot_segid_1) orient end
end if

write coordinates format=pdbo output=$output_pdb_filename end

set message=normal echo=on end
display OUTPUT: $output_pdb_filename

! end of the recipe
stop
