! prot_break.cns
!    Detect protein chain breaks
!
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!
   evaluate ($pbreak=0)

   for $id1 in id ( name C and bondedto(name CA) and bondedto(name O) ) loop pbreak

     show (segid) (id $id1)
     evaluate ($segid1=$result)
     show (resid) (id $id1)
     evaluate ($resid1=$result)
     show (resn) (id $id1)
     evaluate ($resn1=$result)

     show sum(1) (id $id1)
     if ( $result = 0 ) then
       display unknown coordinates for segid $segid1 resn $resn1 resid $resid1 name C
       display this coordinate must be known for automatic protein chain break detection
       abort
     end if

     identity (store1) ( name N and bondedto( segid $segid1 and resid $resid1 and name c ) )

     if ( $select = 1 ) then
       show element (store1) (attribute store1 > 0)
       evaluate ($id2=$result)
       show (segid) (id $id2)
       evaluate ($segid2=$result)
       show (resid) (id $id2)
       evaluate ($resid2=$result)
       show (resn) (id $id2)
       evaluate ($resn2=$result)

       show sum(1) (id $id2)
       if ( $result = 0 ) then
         display unknown coordinates for segid $segid2 resn $resn2 resid $resid2 name N
         display this coordinate must be known for automatic protein chain break detection
         abort
       end if

       pick bond
         (name c and segid $segid1 and resid $resid1)
         (name n and segid $segid2 and resid $resid2)
         geometry

       if ( $result > &pbreak_cutoff ) then
         evaluate ($pbreak=$pbreak+1)
         evaluate ($seg1.$pbreak=$segid1)
         evaluate ($res1.$pbreak=$resid1)
         evaluate ($seg2.$pbreak=$segid2)
         evaluate ($res2.$pbreak=$resid2)
         if ( $resn2 = PRO ) then
           evaluate ($patch.$pbreak=DPPP)
         elseif ( $resn2 = CPR ) then
           evaluate ($patch.$pbreak=DPPP)
         else
           evaluate ($patch.$pbreak=DPEP)
         end if
       end if
     end if

   end loop pbreak

   for $id1 in id ( name BB ) loop cgpbreak

     show (segid) (id $id1)
     evaluate ($segid1=$result)
     show (resid) (id $id1)
     evaluate ($resid1=$result)
     show (resn) (id $id1)
     evaluate ($resn1=$result)

     show sum(1) (id $id1)
     if ( $result = 0 ) then
       display unknown coordinates for segid $segid1 resn $resn1 resid $resid1 name BB
       display this coordinate must be known for automatic protein chain break detection
       abort
     end if

     for $id2 in id ( name BB and bondedto( segid $segid1 and resid $resid1 and name BB ) ) loop cg2pbreak

       show (segid) (id $id2)
       evaluate ($segid2=$result)
       show (resid) (id $id2)
       evaluate ($resid2=$result)
       show (resn) (id $id2)
       evaluate ($resn2=$result)
  
       show sum(1) (id $id2)
       if ( $result = 0 ) then
         display unknown coordinates for segid $segid2 resn $resn2 resid $resid2 name BB
         display this coordinate must be known for automatic protein chain break detection
         abort
       end if

       pick bond
         (name BB and segid $segid1 and resid $resid1)
         (name BB and segid $segid2 and resid $resid2)
         geometry

       if ( $result > &pcgbreak_cutoff ) then
         evaluate ($pbreak=$pbreak+1)
         evaluate ($seg1.$pbreak=$segid1)
         evaluate ($res1.$pbreak=$resid1)
         evaluate ($seg2.$pbreak=$segid2)
         evaluate ($res2.$pbreak=$resid2)
         evaluate ($patch.$pbreak=DCGP)
       end if

     end loop cg2pbreak

   end loop cgpbreak

   evaluate ($counter=1)

   while ($counter <= $pbreak) loop delete
     if ($patch.$counter ne "DCGP") then
       patch $patch.$counter
         reference=-=(segid $seg1.$counter and resid $res1.$counter)
         reference=+=(segid $seg2.$counter and resid $res2.$counter)
       end
     else
       patch $patch.$counter
         reference=-=(segid $seg1.$counter and resid $res1.$counter and name BB)
         reference=+=(segid $seg2.$counter and resid $res2.$counter and name BB)
       end
     end if
     buffer message
       display peptide link removed (applied $patch.$counter): from \
$seg1.$counter[a4] $res1.$counter[a4] to $seg2.$counter[a4] $res2.$counter[a4]
     end
     evaluate ($counter=$counter+1)
   end loop delete



